{"pages":[],"posts":[{"title":"【前端】ES6 Reflect","text":"1. Reflect 设计目的Reflect对象与Proxy对象一样，也是ES6 为了操作对象而提供的新API。Reflect对讲的设计目的有这样几个将Obejct对象上的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同事再Object和Reflect对象上部署，未来的新方法将之部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。修改某些Object方法返回的结果，让其变得合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，二Reflect.defineProperty(object, name, desc) 则会返回false1234567891011121314 // 老写法try { Object.defineProperty(target, property, attributes); // success} catch (e) { // failure}// 新写法if (Reflect.defineProperty(target, property, attributes)) { // success} else { // failure}让Object操作都变成函数行为，某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // trueReflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。123456789Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target, name, value, receiver); if (success) { console.log('property ' + name + ' on ' + target + ' set to ' + value); } return success; }});上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。下面是另一个例子。1234567891011121314var loggedObj = new Proxy(obj, { get(target, name) { console.log('get', target, name); return Reflect.get(target, name); }, deleteProperty(target, name) { console.log('delete' + name); return Reflect.deleteProperty(target, name); }, has(target, name) { console.log('has' + name); return Reflect.has(target, name); }});上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。有了Reflect对象以后，很多操作会更易读。12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 12. 静态方法Reflect对象一共有 13 个静态方法。12345678910111213- Reflect.apply(target, thisArg, args)- Reflect.construct(target, args)- Reflect.get(target, name, receiver)- Reflect.set(target, name, value, receiver)- Reflect.defineProperty(target, name, desc)- Reflect.deleteProperty(target, name)- Reflect.has(target, name)- Reflect.ownKeys(target)- Reflect.isExtensible(target)- Reflect.preventExtensions(target)- Reflect.getOwnPropertyDescriptor(target, name)- Reflect.getPrototypeOf(target)- Reflect.setPrototypeOf(target, prototype)上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。Reflect.get(target, name, reciver)Reflect.get 方法查找并返回target对象name属性，如果没有该属性，则返回undefined1234567891011var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; },}Reflect.get(myObject, 'foo') // 1Reflect.get(myObject, 'bar') // 2Reflect.get(myObject, 'baz') // 3如果name属性部署了读取函数getter则读取函数的this绑定receiver1234567891011121314var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; },};var myReceiverObject = { foo: 4, bar: 4,};Reflect.get(myObject, 'baz', myReceiverObject) // 8","link":"/2020/08/18/ES6-Reflect/"},{"title":"HTML理论知识","text":"HTMLHTML 简介html是缩写 全程 Hyper Text Marked Language (超文本标记语言)超文本超级文本标记：标示语言：汉语英语法语，html是机器语言的一种总结：比普通文本牛并且又标示符号的机器语言，html是为网页创建的一种标记语言，也就是说他是运行在浏览器上。版本：目前的版本是HTML5为什么要创建一个html呢.html 是一个扩展名，靠浏览器来解析的文件。1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;HTML字符集网页种特殊意义的字符键盘上没有的字符规则以&amp;开始以;结尾例子字符集字符集2字符集3字符集4HTML 块级元素特点：总是在新行上开始高度和行高以及内外边距都是可控制的宽度缺省默认就是100%宽度功能：主要是用来搭建网站架构，页面布局，承载内容div: 架构、结构p: 段落h1-h6: 标题ol 有序列表配合 li 使用ul 无序列表配合 li 使用hr 水平线 单标签noscript: chrome禁止javascript脚本代码运行时的提示内容table 表格form 表单pre 定义预格式文本，一般配合code使用所有块级元素：h1-h6&gt;&gt;1-6级标题p&gt;&gt;段落div&gt;&gt;定义文档中的节ul&gt;&gt;定义无序列表ol&gt;&gt;定义有序列表li&gt;&gt;定义无序列表与有序列表中的项hr&gt;&gt;水平线address&gt;&gt;定义文档作者或拥有者的联系信息blockquote&gt;&gt;定义长的引用pre&gt;&gt;定义预格式文本form&gt;&gt;定义表单fieldset&gt;&gt;定义围绕表单中元素的边框legend&gt;&gt;定义 fieldset 元素的标题figure&gt;&gt;定义媒介内容的分组，以及它们的标题。figcaption&gt;&gt;定义 figure 元素的标题audio&gt;&gt;定义声音内容video&gt;&gt;定义视频nav&gt;&gt;定义导航链接dl&gt;&gt;定义定义列表dt&gt;&gt;定义定义列表中的项目dd&gt;&gt;定义定义列表中项目的描述menu&gt;&gt;定义命令的菜单/列表table&gt;&gt;定义表格caption&gt;&gt;定义表格标题tbody&gt;&gt;定义表格主体thead&gt;&gt;定义表格头部tfoot&gt;&gt;定义表格中的表注内容（脚注）tr&gt;&gt;定义表格中的行th&gt;&gt;定义表格中的表头单元格colgroup&gt;&gt;定义表格中供格式化的列组col&gt;&gt;定义表格中一个或多个列的属性值。【在colgroup中使用 】header&gt;&gt;定义 section 或 page 的页眉footer&gt;&gt;定义 section 或 page 的页脚section&gt;&gt;定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分article&gt;&gt;定义文章aside&gt;&gt;定义页面内容之外的内容。【可用作文章的侧栏。】datails&gt;&gt;定义元素的细节。【用于描述有关文档或文档片段的详细信息。】summary&gt;&gt;为 details 元素定义可见的标题。规范：段落需要用：P, 结构用:div行内元素特点：和其他元素都在一行显示不独占一行高、行高、顶部、底部、的边距是不可以修改的宽度就是文字的宽度功能：用户加强内容显示，控制细节所有元素：常用标签：span: 文档中的节a: 跳转页面用的新页面打开1&lt;a href=\"https://baidu.com\" target=\"__blank\"&gt;我要去百度&lt;/a&gt;本页面打开1&lt;a href=\"https://baidu.com\"&gt;我要去百度&lt;/a&gt;code: 代码文本em: 文字倾斜i: 文字倾斜 但是一般用作图标b: 文字加粗strong: 文字加粗br&gt;&gt;定义换行a&gt;&gt;定义超链接i&gt;&gt;定义文字倾斜b&gt;&gt;定义文字加粗em&gt;&gt;定义文字倾斜，语义更加强调abbr&gt;&gt;定义缩写bdi&gt;&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置bdo&gt;&gt;定义文字方向cite&gt;&gt;定义引用code&gt;&gt;定义计算机代码文本dfn&gt;&gt;定义定义项目ins&gt;&gt;定义被插入文本kbd&gt;&gt;定义键盘文本Mark&gt;&gt;定义有记号的文本q&gt;&gt;定义短的引用rp&gt;&gt;定义若浏览器不支持 ruby 元素显示的内容rt&gt;&gt;定义 ruby 注释的解释ruby&gt;&gt;定义 ruby 注释samp&gt;&gt;定义计算机代码样本small&gt;&gt;定义小号文本strong&gt;&gt;定义语气更为强烈的强调文本，文字加粗sup&gt;&gt;定义上标文本sub&gt;&gt;定义下标文本time&gt;&gt;定义日期/时间var&gt;&gt;定义文本的变量部分wbr&gt;&gt;定义可能的换行符label&gt;&gt;定义 input 元素的标注datalist&gt;&gt;定义下拉列表Keygen&gt;&gt;定义生成密钥。output&gt;&gt;定义输出的一些类型。【如脚本输出】map&gt;&gt;定义图像映射area&gt;&gt;定义图像地图内部的区域source&gt;&gt;定义媒介源track&gt;&gt;定义用在媒体播放器中的文本轨道link&gt;&gt;定义文档与外部资源的关系command&gt;&gt;定义命令按钮style&gt;&gt;定义文档的样式信息span&gt;&gt;定义文档中的节base&gt;&gt;定义页面中所有链接的默认地址或默认目标行内块元素功能用户加强内容显示，控制细节特点和其他元素都在一行显示，不独占一行高、行高、顶部、底部边距都是可修改的宽度默认就是内容的宽度，但是是可修改的元素input： 定义输入控件type: text 默认输入文本1&lt;input type=\"text\"&gt;type: password1&lt;input type=\"password\" placeholder=\"密码...\"&gt;其他12345678910111213141516&lt;input type=\"text\" placeholder=\"邮箱...\"&gt;&lt;input type=\"password\" placeholder=\"密码...\"&gt;&lt;input type=\"checkbox\" name=\"1\"&gt; &lt;!-- radio 当name一致时就是单选 --&gt;&lt;input type=\"radio\" name=\"1\"&gt; &lt;input type=\"radio\" name=\"1\"&gt;&lt;input type=\"radio\" name=\"1\"&gt;&lt;input type=\"radio\" name=\"1\"&gt; &lt;!-- 重置 --&gt;&lt;input type=\"reset\"&gt; &lt;!-- 提交 --&gt;&lt;input type=\"submit\"&gt; &lt;!-- 按钮 --&gt;&lt;input type=\"button\" value=\"button\"&gt; &lt;!-- 文件 --&gt;&lt;input type=\"file\" name=\"文件提交\" id=\"\"&gt;textarea 文本域select 选项框，配合option使用img 放置图片所有行内块级元素img&gt;&gt;定义图像input&gt;&gt;定义输入控件meter &gt;&gt;定义预定义范围内的度量progress&gt;&gt;定义任何类型的任务的进度textarea&gt;&gt;定义多行的文本输入控件button&gt;&gt;定义按钮select&gt;&gt;定义选择列表（下拉列表）iframe&gt;&gt;定义内联框架canvas&gt;&gt;定义图形td&gt;&gt;定义表格中的单元格HTML规范块级元素与块级元素平级，行内元素与行内元素平级块元素可以包含内联元素或某些块元素，但内联元素不能包含块元素，它只能包含其它的内联元素123&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素h1、h2、h3、h4、h5、h6、p、dt块级元素不能放在标签p里面li 标签可以包含 div 标签，因为li 和 div 标签都是装载内容的容器","link":"/2020/12/24/HTML%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"},{"title":"【git action】【Travis-ci】Hexo的持续集成","text":"简介分别使用使用Travis与github action 实现hexo自动部署前置工作需要将hexo博客的源码上传到githubTraivs-ciTravis 包括两个版本https://travis-ci.com/ 收费使用https://travis-ci.org/ 针对个人开源项目免费使用使用Travis打开第二个免费使用的网站，使用github登录、进入这个页面https://github.com/settings/installations/11222175在页面中选择Only select repositories，选中之前上传的hexo博客源码库之后回到Travis-ci 点击头像，点击 settings按钮这里选择开始上传的博客仓库配置环境变量访问github账户设置 &gt; tokens生成新的Token Generate new token填入Token描述，并且选择repo全部权限将生成的Toke复制保存下来，这个token只出现一次，请妥善保存访问Travis CI 的仓库设置、将两个变量填入Hexo 博客配置在你的hexo博客根目录下新建.travis.yml文件填入以下内容123456789101112131415161718192021222324language: node_js ## 运行环境node_js: ## node_js 版本 - lts/*cache: directories: - node_modules ## node_modules 缓存before_install: - export TZ='Asia/Shanghai' ## 设置时区branches: only: - master ## 监听变化的分支 当github仓库中你上传的Hexo源码发生变化时install: ## 安装依赖 - npm install hexo-cli -g - npm installscript: ## 生成文章 - hexo gafter_script: ## 将静态文章上传到githubpage的脚本 - cd ./public - git init - git config user.name \"你的github用户名\" - git config user.email \"你的邮箱\" - git add . - git commit -m \"Travis CI Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" - git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master尝试是否成功在本地的hexo 使用 git push12345git add .git commit -m 'travis ci test'git push如果你配置成功的话、这里会显示passingGitHub Actions生成私钥和公钥如果有则直接到C:\\Users\\[你的windows用户名]\\.ssh文件夹下将id_rsa中的内容复制出来，到自己博客源码库的Settings &gt; Secrets选项、选择new Secrets填写变量名ACTION_DEPLOY_KEY将复制的私钥填在value里创建Actions选择Hexo源码库的Actions栏,点击 New worlkflow这两个选项随便选一个删掉默认内容，吧下面的配置复制过去123456789101112131415161718192021222324252627282930name: Build and Update wxperia.com for github pageson: pushjobs: build: runs-on: macOS-latest steps: - uses: actions/checkout@v1 - name: Use Node.js 10.x uses: actions/setup-node@v1 with: node-version: \"10.x\" - name: Setup Hexo env env: ACTION_DEPLOY_KEY: ${{ secrets.ACTION_DEPLOY_KEY }} run: | # set up private key for deploy mkdir -p ~/.ssh/ echo \"$ACTION_DEPLOY_KEY\" &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # set git infomation git config --global user.name 'github用户名' git config --global user.email '邮箱' # install dependencies npm i -g hexo-cli npm i - name: Deploy run: | # generate and depoly hexo g -d成功后可以在Actions中看到以下内容","link":"/2020/08/14/Hexo%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"title":"【前端】JS控制浏览器全屏","text":"起因最近有个大屏的android设备需要全屏，找了半天都没发现手机版的chrome没有全屏功能。所以就考虑使用js来实现全屏。代码12345678910111213141516171819 function enterfullscreen() {//进入全屏 var docElm = document.documentElement;//W3C if (docElm.requestFullscreen) { docElm.requestFullscreen(); }//FireFox else if (docElm.mozRequestFullScreen) { docElm.mozRequestFullScreen(); }//Chrome等 else if (docElm.webkitRequestFullScreen) { docElm.webkitRequestFullScreen(); }//IE11 else if (elem.msRequestFullscreen) { elem.msRequestFullscreen(); } }退出全屏的方法。1234567891011121314function exitfullscreen() { //退出全屏 if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.webkitCancelFullScreen) { document.webkitCancelFullScreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); }}angular按钮事件调用12345678$scope.isfullScreen = function(e){ if(_funnS){ enterfullscreen() }else { exitfullscreen() } _funnS =!_funnS }..end…","link":"/2020/01/13/JS%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A8%E5%B1%8F/"},{"title":"【设计模式】js面向对象","text":"js抽象类12345678910111213//抽象类的工厂 方法function VehicleFactory(subType, superType) { if (typeof VehicleFactory[superType] === 'function') { function Fn() {} Fn.prototype = new VehicleFactory[superType]() //subType.constryctor 默认是 vehicleFactory 这里要重新指向下 subType.constructor = subType subType.prototype = new Fn() } else { //如果工厂方法内没有这种抽象类，返回一个错误 throw new Error('没有创建此抽象类') }}12345678910111213//设置抽象类构造方法VehicleFactory.Book = function() { this.type = 'Book'}//创建抽象类的公共方法VehicleFactory.Book.prototype = { getType: function() { throw Error('抽象类方法不能调用') }, getName: function() { throw Error('抽象方法不能直接调用') }}通过抽象工厂方法创建实例12345678910111213var Javascript = function() { this.name = 'Javascript'}VehicleFactory(Javascript, 'Book')Javascript.prototype.getName = function() { console.log(this.name)}Javascript.prototype.getType = function() { console.log(this.type)}var js = new Javascript()js.getName() //javascriptjs.getType() //Book","link":"/2020/01/14/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"【前端|ES6】Set与Map的区别","text":"Set 与 Map 是 ES6 规范中提供的新数据结构。Set 类似于数组，但是成员的值都是唯一的，没有重复的值。使用123456789const s = new Set()const list = [1, 1, 2, 2, 3, 4, 4]list.forEach((item, index) =&gt; { s.add(item)})console.log(s)//outPut Set { 1, 2, 3, 4 }Set 可以接收一个数组，用于初始化12[...new Set(array)]//可以用作数组去重Set 也可以接收一个字符串12[...new Set('aabbcc')].join('')//abcSet 添加值时，不会发生类型转换 5 和 '5' 是不同的值，这样的比较类似于 === 唯一的区别就是 Set 加入值时，认为NaN等于自身，而 === 认为 NaN 不等于自身。","link":"/2020/01/20/Set%E4%B8%8EMap%E5%8C%BA%E5%88%AB/"},{"title":"【vuex】Vuex填坑记录","text":"简介Vuex如何在项目中的正确使用姿势vuex store引用顺序一定记得 store 要在 render 函数前引用！！！！123456new Vue({ el: '#app', router, store, render: h =&gt; h(App),})store结构文件名说明actions.jsmutations的集合，弥补mutations不能异步处理数据的问题getters.js直接获取state中的值mutations-types.js管理mutations的类型mutations.js修改state中的值states.js存放变量index.jsstore入口文件，初始化、配置vuex基本内容actions.js1234567891011121314151617import axios from 'axios'import * as types from './mutations-types'const cachePlain = []export const initAllPlain = function({ commit}) { let cachePlain = await getPlain() commit(types.INIT_ALL_PLAIN, cachePlain)}export const initcurrentPlain = function({ commit, state}) { commit(types.SET_CURRENT_PLAIN, state.allPlain[0])}getters.js1234567export const currentPlain = states =&gt; states.currentPlainexport const allPlain = states =&gt; states.allPlainexport const currentTp = states =&gt; { return states.currentPlain[states.id].testPoint[states.currentTestTpIndex]}export const id = states =&gt; states.idexport const currentTestTpIndex = states =&gt; states.currentTestTpIndexmutations-types.js这样写可以很大程度上的利用起vscode的自动补全, 保证commit的正确性12345678export const SET_CURRENT_PLAIN = 'SET_CURRENT_PLAIN';export const SET_CURRENT_PLAIN_TP = 'SET_CURRENT_PLAIN_TP';export const INIT_ALL_PLAIN = 'INIT_ALL_PLAIN';export const SET_TEST_LIST = 'SET_TEST_LIST';export const SET_TEST_LIST_BY_ID = 'SET_TEST_LIST_BY_ID';export const SET_CURRENT_PLAIN_INDEX = 'SET_CURRENT_PLAIN_INDEX';export const SET_CURRENT_PLAIN_TP_INDEX = 'SET_CURRENT_PLAIN_TP_INDEX'export const SET_CURRENT_PLAIN_TP_BY_ID = 'SET_CURRENT_PLAIN_TP_BY_ID'mutations.jsmutation中尽量只用来修改数据或简单的处理数据，需要复杂处理的数据使用action1234567891011121314151617181920212223242526272829303132import * as types from './mutations-types'const mutations = { [types.SET_CURRENT_PLAIN](states, data) { states.currentPlain = data; }, [types.SET_CURRENT_PLAIN_TP](states, temperature) { states.currentPlain[states.id].testPoint[states.currentTestTpIndex] = temperature }, [types.SET_TEST_LIST](states) { states.currentPlain[states.id].testPoint[states.currentTestTpIndex].testlist.push(data.testtp) }, [types.SET_TEST_LIST_BY_ID](states, { id, index, testItem }) { states.currentPlain[id].testPoint[index].textlist.push(testItem) }, [types.INIT_ALL_PLAIN](states, data) { states.allPlain = data }, [types.SET_CURRENT_PLAIN_TP_BY_ID](states, { id, index, temperature }) { states.currentPlain[id].testPoint[index].temperature = temperature }}export default mutationsindex.js12345678910const states = { currentPlain: {}, testedPlain: {}, allPlain: [], id: '', currentTestTpIndex: 0, currentID: ''}export default states最后vuex 比较适合大型项目，或有大量数据需要所有组件共享的情景，如果只是几个页面就能梭完，不要为了使用vuex而使用vuex。","link":"/2020/03/10/Vue%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"【vue源码阅读注释】-Event.js","text":"Vue中 $on 与 $emit的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/* @flow */import { tip, toArray, hyphenate, formatComponentName, invokeWithErrorHandling} from '../util/index'import { updateListeners} from '../vdom/helpers/index'//在new vue 时执行这个方法将事件初始化export function initEvents(vm: Component) { vm._events = Object.create(null)//创建一个空对象，作为事件的容器 vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) { updateComponentListeners(vm, listeners) }}let target: anyfunction add(event, fn) { target.$on(event, fn)}function remove(event, fn) { target.$off(event, fn)}function createOnceHandler(event, fn) { const _target = target return function onceHandler() { const res = fn.apply(null, arguments) if (res !== null) { _target.$off(event, onceHandler) } }}export function updateComponentListeners( vm: Component, listeners: Object, oldListeners: ? Object) { target = vm updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm) target = undefined}//挂载 $on $once $emit $ofexport function eventsMixin(Vue: Class &lt; Component &gt; ) { const hookRE = /^hook:/ Vue.prototype.$on = function(event: string | Array &lt; string &gt; , fn: Function): Component { const vm: Component = this if (Array.isArray(event)) { //支持数组传入，同时注册多个事件 for (let i = 0, l = event.length; i &lt; l; i++) { vm.$on(event[i], fn) } } else { //检查是否存在这个方法名，每没有则创建一个空数组并且将方法push (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) { vm._hasHookEvent = true } } return vm } Vue.prototype.$once = function(event: string, fn: Function): Component { const vm: Component = this //定义一个on方法。同时执行方法注销和执行 function on() { //注销这个方法 vm.$off(event, on) //执行fn,传入参数 fn.apply(vm, arguments) } on.fn = fn vm.$on(event, on) return vm } Vue.prototype.$off = function(event ? : string | Array &lt; string &gt; , fn ? : Function): Component { const vm: Component = this // all if (!arguments.length) { //不传参数直接清空事件容器，关闭所有事件 vm._events = Object.create(null) return vm } // array of events //兼容数组形式一次传入多个事件名 if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { vm.$off(event[i], fn) } return vm } // specific event // 获取当前事件对应的方法是否为空，是则直接跳出方法 const cbs = vm._events[event] if (!cbs) { return vm } // 如果没有传入需要结束的方法则直接清空所有方法。 if (!fn) { vm._events[event] = null return vm } // specific handler // 正常使用 let cb let i = cbs.length while (i--) { cb = cbs[i] // 判断对应方法进行删除 if (cb === fn || cb.fn === fn) { cbs.splice(i, 1) //删完break性能优化 break } } return vm } Vue.prototype.$emit = function(event: string): Component { const vm: Component = this if (process.env.NODE_ENV !== 'production') { //大小写报错 const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) { tip(`Event \"${lowerCaseEvent}\" is emitted in component ` +`${formatComponentName(vm)} but the handler is registered for \"${event}\". ` +`Note that HTML attributes are case-insensitive and you cannot use ` +`v-on to listen to camelCase events when using in-DOM templates. ` +`You should probably use \"${hyphenate(event)}\" instead of \"${event}\".` ) } } let cbs = vm._events[event] if (cbs) { cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) const info = `event handler for \"${event}\"` for (let i = 0, l = cbs.length; i &lt; l; i++) { //执行方法，并且捕获错误，兼容异步方法 invokeWithErrorHandling(cbs[i], vm, args, vm, info) } } return vm }}//拉到这了export function invokeWithErrorHandling ( handler: Function, context: any, args: null | any[], vm: any, info: string) { let res try { //判断是否传参分情况执行 res = args ? handler.apply(context, args) : handler.call(context) if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) { res.catch(e =&gt; handleError(e, vm, info + ` (Promise/async)`)) // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true } } catch (e) { handleError(e, vm, info) } return res}","link":"/2020/05/25/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Event-js/"},{"title":"【vue源码阅读注释】","text":"水平有限，好记性不如烂笔头。基于 `vue2.6.11` 版本的源码,我也不知道为什么要写这篇博客,可能是因为一些视频里讲的不太清楚吧，自己也想记录下。目录结构srccompiler 编译相关core 核心部分platforms 平台兼容server ssr服务端渲染sfc vue解析shared 工具类等公共代码new Vue({})Vue 定义在 src/core/instance/index.js 中123456789101112//这里使用Es5的类的实现方式function Vue(options) { //这里用来保证用户一定是用new关键字来使用这个类的。 if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { return new Vue(option) //这行代码是我加的，我不知道为什么vue的作者不这样写，这样就能保证用户一定是用new关键字来初始化的 warn('Vue is a constructor and should be called with the `new` keyword') } //这里就开始向这个实例挂载各种属性和方法了 this._init(options)}Vue 实例化之后，调用了 Vue._init() 这个方法定义在 src/core/instance/init.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Vue.prototype._init = function(options ? : Object) { const vm: Component = this //this.指向刚刚的Vue实例 // a uid vm._uid = uid++ //这里给每个创建的实例加一个uid //下面这一段，我看不懂到底要干嘛可能是编译相关？ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { startTag = `vue-perf-start:${vm._uid}` endTag = `vue-perf-end:${vm._uid}` mark(startTag) } // a flag to avoid this being observed vm._isVue = true // merge options //合并options 也就是平时vue文件中export default {} 的内容这样就能实现使用this.xxx直接调用各种属性方法。并且针对不同的组件使用不同的合并策略 if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm //各种全局方法的初始化 initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) //挂载你的data数据下面详细讲下这里 initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure( `vue ${vm._name} init` , startTag, endTag) } if (vm.$options.el) { //挂载到dom,这时候界面就渲染出来了 vm.$mount(vm.$options.el) }}Vue 这里我们先看下，为什么能直接用 this.xxx 来调用 data , methods 中的各种属性方法。这个给 src\\core\\instance\\state.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586export function initState(vm: Component) { vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) //如果定义了props,就初始化props if (opts.methods) initMethods(vm, opts.methods) //如果定义了methods就初始化methods if (opts.data) { //这个方法就是罪魁祸首，我们康康他 initData(vm) } else { observe(vm._data = {}, true /* asRootData */ ) } if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) }}function initData(vm: Component) { //获取当前组件实例中的data let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : //这个方法会把data中的this指向修改为vm,并且将它传入data方法中 data || {} //判断他是否是一个普通对象， //isPlainObject这里大概是这样实现的 Object.prototype.toString.call(data) === '[object] [Object]'如果不是就要给你一个警告了 if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) //获取data中的属性名 const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { //遍历属性，我也不知道为什么不用 for(let key in data)maybe这样性能更好？ const key = keys[i] //判断是否在前面初始化的props 或者 methods中是否有重复定义的属性 if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn(`Method \"${key}\" has already been defined as a data property.` , vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn(`The data property \"${key}\" is already declared as a prop. ` +`Use prop default value instead.` , vm ) //这是给自己做判断呢吧 } else if (!isReserved(key)) { //代理vm的get/set方法，让他从_data中获取对应的数据 proxy(vm, `_data` , key) } } // observe data observe(data, true /* asRootData */ )}export function proxy(target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter() { // 相当于 vm[sourseKey][key] return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter(val) { this[sourceKey][key] = val } //看到这里，我有点忘记defineProperty是用来干嘛的，然后就取去查了文档 //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty //Object.defineProperty(obj, prop, descriptor) /* obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol 。 descriptor 要定义或修改的属性描述符。 */ Object.defineProperty(target, key, sharedPropertyDefinition)}","link":"/2020/05/14/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-new%20Vue()/"},{"title":"【vue源码阅读】Vue简单实现-router","text":"vue-router的简单实现实现hash路由跳转实现vue插件形式引用router-link router-view实现插件使用这点在vue官方文档中有提到，vue.use() 会调用传入对象的install方法，并且注入vue实例,所以只需要在导出的时候保证export default 的对象有install这个方法。12345678910let Vue;class mVueRouter { }mVueRouter.install = function(_vue){ Vue = _vue //获取vue实例，之后要用}实现页面根据hash地址变化而变化利用Vue本身的响应式原理实现检测数据变化，解析传入的route配置12345678910111213141516171819202122232425262728293031323334353637 class mVueRouter { constructor(options) { //获取用户配置 this.$options = options; //创建一个路由path和route映射 this.routeMap = {}; //将来当前路径current需要响应式 //利用vue响应式原理可以做到这一点 this.app = new Vue({ data: { current: \"/\" } }); } init() { //监听地址变化实时修改this.app.current的值 this.bindEvent(); //初始化路由地址配置 this.createRouteMap(this.$options); } bindEvent() { window.addEventListener(\"load\", this.onHashChange.bind(this),false); window.addEventListener(\"hashchange\", this.onHashChange.bind(this),false); } onHashChange(e) { this.app.current = window.location.hash.slice(1) || \"/\"; } createRouteMap(options) { options.routes.forEach(item =&gt; { /* '/home': { path:'/home', component: 'home' } 大概就是这样子 */ this.routeMap[item.path] = item; }); }}全局绑定router-link与router-view 组件利用install时,获得的Vue实例来创建这两个组件1234567891011121314151617181920212223242526272829303132333435initComponent() { Vue.component(\"router-view\", { //h函数方式实现 render: h =&gt; { //获取需要渲染的函数 let component = this.routeMap[this.app.current].component; return h(component); } //react jsx方式实现 需要 /* render(h) { return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt; } */ }); Vue.component(\"router-link\", { props: { to: String }, //使用箭头函数 这里的this指向了 mVUeRouter render(h) { return h( \"a\", { attrs: { href: \"#\" + this.to } }, this.$slots.default ); } //react jsx方式实现 需要 /* render(h) { return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt; } */ }); }完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102let Vue;class mVueRouter { constructor(options) { this.$options = options; //创建一个路由path和route映射 this.routeMap = {}; //将来当前路径current需要响应式 //利用vue响应式原理可以做到这一点 this.app = new Vue({ data: { current: \"/\" } }); } init() { //解析路由配置 this.bindEvent(); //初始化路由地址配置 this.createRouteMap(this.$options); //全局挂载两个组件 this.initComponent(); } createRouteMap(options) { options.routes.forEach(item =&gt; { // '/home':object {} this.routeMap[item.path] = item; }); } bindEvent() { window.addEventListener(\"load\", this.onHashChange.bind(this),false); window.addEventListener(\"hashchange\", this.onHashChange.bind(this),false); } onHashChange(e) { this.app.current = window.location.hash.slice(1) || \"/\"; } initComponent() { Vue.component(\"router-view\", { //h函数方式实现 render: h =&gt; { //获取需要渲染的函数 let component = this.routeMap[this.app.current].component; return h(component); } //react jsx方式实现 需要 /* render(h) { return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt; } */ }); Vue.component(\"router-link\", { props: { to: String }, //使用箭头函数 这里的this指向了 mVUeRouter render(h) { return h( \"a\", { attrs: { href: \"#\" + this.to } }, this.$slots.default ); } //react jsx方式实现 需要 /* render(h) { return &lt;a href={this.to}&gt;{this.$slots.default}&lt;/a&gt; } */ }); }}mVueRouter.install = function(_vue) { /* Vue.use()会调用这个install方法，将 _vue 实例传进来 */ _vue.mixin({ /* mixin 会在所有的组件在beforeCreate钩子中执行， */ beforeCreate() { //这里的代码将来会在初始化的时候被调用 //将router挂载到prototype上 //这里检查Vue实例是否已经有了对应的router实例保证router只挂载一次 if (!this.$options.router) { /* 在new Vue({ router })时起作用 */ Vue.prototype.$router = this.$options.router; //初始化组件 this.$options.router.init(); } // Vue.prototype.$router = this.$options.router; } }); Vue = _vue; //在beforeCreate钩子前挂载router实例到根节点上};export default mVueRouter;","link":"/2020/05/26/Vue%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5-router/"},{"title":"【手写vuex】Vue简单实现-vuex","text":"vuex 简单实现vuex 实现不难，稍微要想一下的就是实现禁止直接修改state稍微有一点经验的同学就能想到使用Object.defineProperty实现vue插件形式使用实现commit dispatch 方法实现mutations getters actions 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546let Vue;function install(_vue) { Vue = _vue; /* 全局混入，在beforeCreate执行时，将$store挂载到全局。 实现在所有组件调用this.$store */ Vue.mixin({ beforeCreate() { /*只有在Vue实例初始化时有传入store才进行挂载，保证store只挂载一次， */ if (this.$options.store) { Vue.prototype.$store = this.$options.store; } }, });}class store { constructor(options = {}) { // 这里再次利用Vue的特性，进行视图更新 this.state = new Vue({ data: options.state, }); this.mutations = options.mutations || {}; this.actions = options.actions || {}; options.getters &amp;&amp; this.initGetters(options.getters) || {}; } commit = (type, arg) =&gt; { //获取对应的mutations方法，返回commit方法 this.mutations[type](this.state, arg); } dispatch = (type, arg) =&gt; { //传入所有的commit用于修改state return this.actions[type]({ commit: this.commit }, arg); } initGetters = (getters) =&gt; { //获取所有getter方法 Object.keys(getters).forEach((key) =&gt; { Object.defineProperty(getters[key], key, { //代理get方法获取到的值，保证不能被直接修改 get: () =&gt; { return getters[key](this.state); }, }); }); };}","link":"/2020/05/26/Vue%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5-vuex/"},{"title":"【前端】css选择器","text":"css选择器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879li { font-weight: bold;}/* 属性选择器 + ： 获取当前元素相邻满足调监的元素 *//* .red + li{ color: blue; font-size: 100; } *//* ~ ： 获取满足条件的兄弟元素 *//* .red ~ li { color: red; } *//* 相对于父元素的结构伪类 *//* 1、相对于父元素的结构为类 2、查找的类型必须是指定的类型，下面指定的是li 3、在下面的实例代码中，并没有元素字体变为红色，说明只有li的父元素 下的第一个子元素为li时才会生效 */li:first-child { color: red;}li:last-child { color: rgba(15, 65, 58, 0.11);}/* 以上的标签可能不是经常使用的元素， */li:first-of-type { font-size: 100px;}/* 索引从一开始，可以写关键字 */li:nth-child(2) { background: rgba(41, 197, 176, 0.11)}/* 偶数元素添加背景 *//* li:nth-child(even){ background: rgb(2, 124, 133); } li:nth-child(odd){ background: rgb(99, 12, 212); } *//* nth-of-type: 限制类型为li */li:nth-of-type(n+5) { background: rgb(2, 124, 133);}/* 可以写关键字，表达式。 *//* 没有任何的内容，空格都没有 empty */li:empty { background: rgb(163, 13, 13);}html部分123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul&gt; &lt;span&gt;999&lt;/span&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;&lt;/li&gt; &lt;li class=\"bluebl\"&gt;32423423&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;li class=\"red\"&gt;12&lt;/li&gt; &lt;li class=\"blue\"&gt;213&lt;/li&gt; &lt;li class=\"yellow\"&gt;321132&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;","link":"/2020/01/18/css%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"【hexo】hexo博客使用git备份","text":"工作需要用到多台电脑，为了想在每台电脑上都能愉快的写博客。于是上git 新建了一个仓库，clone到本地后，把hexo根目录下除了node_modules文件夹之外、都复制到clone下来的文件夹中，然后直接git push结果发现themes目录下的主题文件夹是空的git 提示123456789hint: You've added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: If you meant to add a submodule, use:hint: git submodule add &lt;url&gt; themes/xxxhint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint: git rm --cached themes/xxxhint: See &quot;git help submodule&quot; for more information.如果在这里直接使用git submodule的话就把主题原作者的仓库放进来了，这样的话自己的修改还是不能正常同步所以需要到github再新建一个仓库用来保存你修改后的主题文件1、首先需要把主题默认的git环境删除、cd进入主题根目录下，使用以下命令清楚默认环境rm -rf ./.git2、将新建的仓库克隆到本地，将清除git环境后的主题根目录下的文件粘贴到clone下来的文件夹中执行以下命令将你修改的主题文件推送到远程仓库123git add .git commit -m 'init'git push由于是克隆的空仓库，应该是可以直接push的。然后将这个克隆下来的文件夹复制到hexo根目录下的themes文件夹中，并且将themes文件夹中的其他主题文件移除。如果文件夹的名字与原主题的名字不一样，需要到hexo根目录下的config.yml，否则会出现博客白屏的情况1theme: 文件夹的名字3、将git子项目关联到你的远程仓库git submodule add https://github.com/xxx/xxx.git themes/xxx这时候在你的hexo根目录下就会多出一个.gitmodules文件1234[submodule \"themes/xxx\"] path = themes/xxx url = https://github.com/xxx/xxx.git这样表示以后此目录下的xxx文件会从这个url指向的git仓库中获取4、子项目管理需要进入子项目的文件夹中、对修改进行 git add 、commit、push操作再到hexo根目录进行 git add 、 commit、push 才能更新子项目中的修改。其实两个项目还是独立的，只是在父级项目clone的时候会在这个目录下连带子项目一起克隆下来版本的管理还是各自独立的。","link":"/2019/09/09/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8git%E5%A4%87%E4%BB%BD/"},{"title":"【前端】jQuery事件执行多次","text":"原因jQuery .click(fun) 会重复的把 fun 绑定到 click 事件上，所以点击一次就会重复执行多次 fun推测原理：是个数组，然后click只是把方法push进数组进，事件触发的时候遍历执行了;解决方法一使用：1$('')[0].onclick = function() {};缺点： 如果是 $('.class')等可能会获取到多个元素的选择器就会出现只有第一个元素绑定了方法的问题;解决方法二使用：12$('').off('click').on('click', function() {})//先关闭再绑定解决方法三使用：123$('.noteBtn').unbind('click').on('click', function() { consoel.log(\"ok\");});","link":"/2020/02/28/jQuery%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%AC%A1/"},{"title":"【正则】js正则表达式","text":"正则基本用法标识符意义元字符[]表示一个范围|或者 [0-9] | [a-z] 要么为数字，要么为小写字母()分组 ([0-9])([a-z])([A-Z]) 三组，左边开始运算限定符*表示前面的表达式出现了 0 次到多次+表示前面的表达式出现了一次到多次?前面的表达式出现 0次到 1次，最少是 0次，最多是 1次{}{0, } 前面的表达式出现 0次到多次^表示以什么开始，或者取非$表示以什么结束\\d数字中的任意一个\\D非数字中的一个\\w非特殊符号\\W特殊符号\\s空白\\S不空白\\b单词边界\\g全局匹配获取内容基本使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 创建正则表达式对象 * var reg = new RegExp() */var reg = new RegExp(/^\\w+[@]\\w+([.]\\w+){1,2}$/)var str = 'war3hacdsadask@212.com'var result = reg.test(str)// console.log('邮箱')console.log('邮箱: ' + result)/** * 识别正则表达式是否匹配 * */var reg1 = /[a-zA-z]*/console.log(reg1.test('hello'))/** * 正则匹配并且取值 * /g 全局匹配 */var str = '中国移动10086，中国电信10010，中国联通 10000'var result = str.match(/(\\d{5})/g)console.log(result)/** * 提取日期 * 组提取 使用RegExp.$组号 来提取需要的组 */var str = '2017-11-12'var array = str.match(/(\\d{4})[-](\\d{2})[-](\\d{2})/g)console.log(RegExp.$1)var str2 = 'war3hack@qq.com'str2.match(/(\\w+)[@](\\w+)(([.]\\w+){1,2})/)console.log(RegExp.$1)console.log(RegExp.$2)console.log(RegExp.$3)/** * 替换字符串 * */var str = \"我好丑，真的太丑了\"str = str.replace(/丑/g, \"帅\")console.log(str)/** * 去除字符串之间的空格 * */var str3 = \"1 2 3 4 5 6 7 8\"str3 = str3.replace(/\\s+/g, '')console.log(str3)/** * RegExp的 exec方法 */var str4 = '中国移动10086，中国电信10010，中国联通 10000'var reg = /(\\d{5})/gvar arr2 = str4.match(reg)console.log(arr2)var res = reg.exec(str4)while (res != null) { console.log(res) res = reg.exec(str4)}实现表单验证12345&lt;label for=\"\"&gt;QQ&lt;/label&gt;&lt;input type=\"text\" id=\"QQ\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;&lt;label for=\"\"&gt;手机&lt;/label&gt;&lt;input type=\"text\" id=\"phone\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;&lt;label for=\"\"&gt;邮箱&lt;/label&gt;&lt;input type=\"text\" id=\"e-mail\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;&lt;label for=\"\"&gt;座机&lt;/label&gt;&lt;input type=\"text\" id=\"telephone\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;&lt;label for=\"\"&gt;姓名&lt;/label&gt;&lt;input type=\"text\" id=\"fillname\"&gt;&lt;span&gt;&lt;/span&gt;&lt;br /&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function m$(a) { return document.querySelector(a)}check('QQ', m$('#QQ'))check('QQ', m$('#phone'))check('QQ', m$('#e-mail'))check('QQ', m$('#QQ'))function check(type, el) { el.onblur = function() { if (type === 'QQ') { if (/\\d{5,13}/.test(this.value)) { this.nextElementSibling.innerText = \"正确\"; this.nextElementSibling.className = 'right' } else { this.nextElementSibling.innerText = \"错了\"; this.nextElementSibling.className = 'wrong' } } if (type === 'phone') { if (/\\d{11,}/.test(this.value)) { this.nextElementSibling.innerText = \"正确\"; this.nextElementSibling.className = 'right' } else { this.nextElementSibling.innerText = \"错了\"; this.nextElementSibling.className = 'wrong' } } if (type === 'e-mail') { if (/^\\w+[@]\\W+([.]\\w+){1,2}$/.test(this.value)) { this.nextElementSibling.innerText = \"正确\"; this.nextElementSibling.className = 'right' } else { this.nextElementSibling.innerText = \"错了\"; this.nextElementSibling.className = 'wrong' } } if (type === 'telephone') { if (/\\d+[-]\\d{7,8}/.test(this.value)) { this.nextElementSibling.innerText = \"正确\"; this.nextElementSibling.className = 'right' } else { this.nextElementSibling.innerText = \"错了\"; this.nextElementSibling.className = 'wrong' } } if (type === 'fullname') { if (/[\\u4e00-\\u9fa5]/.test(this.value)) { this.nextElementSibling.innerText = \"正确\"; this.nextElementSibling.className = 'right' } else { this.nextElementSibling.innerText = \"错了\"; this.nextElementSibling.className = 'wrong' } } }}","link":"/2020/01/14/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"【前端】js的映射与解析","text":"['1','2','3'].map(parseInt)123['1', '2', '3'].map(parseInt);var a = '20'//console.log(1,NaN,NaN)首先，我们需要了解下 map 这个方法的作用：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。语法123var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array } [, thisArg])参数callback生成新数组元素的函数，使用三个参数：currentValuecallback 数组中正在处理的当前元素。index 可选callback 数组中正在处理的当前元素的索引。array 可选map 方法调用的数组。thisArg 可选执行 callback 函数时值被用作 this 。parseIntparseInt(string, radix) 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。语法1parseInt(string, radix);参数string要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数 10 表示使用十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常认为其值默认为10，但是如果你的代码运行在过时的浏览器中，那么请在使用时总是显式地指定 radix。如果 radix 为0或者为 undefined 或者没有传入的情况下如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。如果字符串 string 以其它任何值开头，则基数是10 (十进制)。使用12345var a = \"050\";a = parseInt(a, 10); //十进制输出a = parseInt(a, 8); //八进制输出不兼容问题：针对”050”这种，调用parseInt(“050”)函数，有些浏览器会当8进制解析，有些浏览器会当10进制解析问题解决回到问题本身12['1', '2', '3'].map(parseInt)//console.log(1,NaN,NaN)实际上可以写成这样123['1', '2', '3'].map((item, index) =&gt; { return parseInt(item, index)})就是顺序执行以下方法123parseInt('1', 0) //10进制或8进制输出parseInt('2', 1) // NaNparseInt('3', 2) // NaN","link":"/2020/01/20/js%E7%9A%84%E6%98%A0%E5%B0%84%E4%B8%8E%E8%A7%A3%E6%9E%90/"},{"title":"【前端】js监听css动画开始和结束","text":"简介项目需求，需要写图片加载时的动画，网上并没有现成的，只能自己摸索着写。一开始用的是setInterval来检查动画属性的状态类似这样来在图片加载出来后去移除加载动画的盒子（这段代码并没有真正的写出来只是个思路）12345678var time = setInterval(function() { var time2 = setTimeout(function() { if (element.style.height === 100) { elemeny.style.display = 'none'; } cleartimeout(time2) })}, 100)但是这样太呆了，于是搜索一番了解到js有animationed和transitioned事件;animationedcss动画播放时, 会发生以下三个事件animationstart css 动画开始后触发animationteration css 动画重复播放时触发animationend css 动画完成后触发具体使用如下1234567891011121314151617//获取元素var monkey = document.querySelector(\"#monkey\");//监听动画开始monkey.addEventListener(\"animationstart\", function(e) { console.log(\"log at beginning of monkey animation\");}, false);//监听动画重复播放monkey.addEventListener(\"animationiteration\", function(e) { console.log(\"log at beginning of each subsequent iteration\");}, false);//监听动画完成monkey.addEventListener(\"animationend\", function(e) { console.log(\"log at end of monkey animation\");}, false);浏览器兼容不同的浏览器有不同的前缀前缀兼容写法No prefixanimationstart, animationiteration, animationendWebkitwebkitAnimationStart, webkitAnimationIteration, webkitAnimationEndMozillamozAnimationStart, mozAnimationIteration, mozAnimationEndMSMSAnimationStart, MSAnimationIteration, MSAnimationEndOoAnimationStart, oAnimationIteration, oAnimationEnd通过建立前缀数组遍历生成所有的兼容写法1234567891011121314//创建兼容性辅助方法var pfx = [\"webkit\", \"moz\", \"MS\", \"o\", \"\"];function prefixedEventListener(element, type, callback) { for (var p = 0; p &lt; pfx.length; p++) { if (!pfx[p]) type = type.toLowerCase(); element.addEventListener(pfx[p] + type, callback, false); }}//使用var monkey = document.querySelector(\"#monkey\");prefixedEventListener(monkey, \"AnimationStart\", function(e) { console.log(\"log at beginning of monkey animation\");});会执行5次addEventListener方法，真正起作用的只有一个。但是用起来很方便。另一个方法123456789101112131415161718192021function whichAnimationEvent() { var t, el = document.createElement(\"fakeelement\"); var animations = { \"animation\": \"animationend\", \"OAnimation\": \"oAnimationEnd\", \"MozAnimation\": \"animationend\", \"WebkitAnimation\": \"webkitAnimationEnd\" } for (t in animations) { if (el.style[t] !== undefined) { return animations[t]; } }}var animationEvent = whichAnimationEvent();element.addEventListener(animationEvent, function() { //do someting when the animation end})transitioned基本原则都一样我就直接上代码了12345678910111213141516171819function whichTransitionEvent() { var t; var el = document.createElement('fakeelement'); var transitions = { 'transition': 'transitionend', 'OTransition': 'oTransitionEnd', 'MozTransition': 'transitionend', 'WebkitTransition': 'webkitTransitionEnd' } for (t in transitions) { if (el.style[t] !== undefined) { return transitions[t]; } }}transitionEvent &amp;&amp; Mapdiv.addEventListener(transitionEvent, function() { // Do something when the transition ends})","link":"/2020/02/28/js%E7%9B%91%E5%90%AC%E5%8A%A8%E7%94%BB%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F/"},{"title":"【node】nodejs学习","text":"NODEJS基础学习 node 的目标可以和后端有效的沟通敏捷的全栈工程化思想实践nodejs是什么Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。JRE java 运行时环境C Runtime. NET CommonLanguage Runtime运行时就是 程序运行的时候 。 运行时库 就是 程序运行时所依赖的库 。运行的时候Runtime 指的是指令加载到内存，并由CPU执行的时候， C代码编译成可执行文件的时候 ，指令没有被CPU执行，这个时候算是 编译时 ，就是 编译的时候 。nodejs特性非阻塞I/O事件驱动nodejs历史Node.js于2009年写成，其原始作者是瑞安·达尔（Ryan Dahl），。Node.js结合了Google的V8、事件驱动模式和低级I/O接口，其设计灵感源自Flickr的一款上传进度栏：在上传过程中，浏览器并不清楚有多少文件已经发送到服务器，除非向服务器进行查询，于是达尔想出了一个更简便的方法。Node.js的开发和维护工作由达尔本人主持，而他所在的Joyent公司也提供了赞助。2009年11月8日，Dahl在欧洲JSConf大会上展示了Node.js项目，并受到了观众赞赏。在演讲中，达尔针对Apache HTTP Server和顺序编程方式提出了批评，认为Apache处理大量并发连接（10, 000甚至更多）的可能性有限，而且顺序编程方式在多连接情况下会造成阻塞，或者消耗更多资源；而Node.js提供了基于事件驱动和非阻塞的接口，可用于编写高并发状态下的程序，而且JavaScript的匿名函数、闭包、回调函数等特性就是为事件驱动而设计的。2010年1月，一款名为“npm”的软件包管理系统诞生。npm使程序员能够更方便地发布和分享Node.js类库及源代码，而且简化了类库安装、升级与卸载的过程。Node.js最初只支持Linux和Mac OS X操作系统。2011年6月，微软和Joyent共同合作，把Node.js移植到了Windows系统上面，并且在7月发布了第一个正式支持Windows系统的版本。2012年1月，达尔离开了Node.js项目，开发工作由他的同事以及npm创始人艾萨克·施吕特（Isaac Schlueter）继续主持。2014年2月，蒂莫西·费里斯（Timothy J. Fontaine）接任项目主管。由于长期对Joyent的管理感到不满，Node.js核心开发者Fedor Indutny在2014年12月制作了分支版本，并起名“io.js”。与Node.js相对的是，io.js采用开放管理模式进行管理，并计划始终采用最新版的V8引擎。为了在用户、厂商和开发者之间获取平衡，Node.js基金会于2015年初成立。基金会得到了IBM、Intel、微软、Joyent等公司的支持。6月，Node.js和io.js开发者社区共同决定合并到Node.js基金会之下。同年9月，Node 4.0发布，Node.js和io.js正式合并。4.0版引入了ES6的语言特性和“长期支持版本”的发布周期。到了2016年，io.js宣布不再发布新版本，并建议开发者换回Node.js。nodejs历史并发处理多进程-C Apache LinuxC多线程- java异步 IO-js协程 - lua go openresty与前端不同JS核心语法不变前端操作 BOM DOM 对象后端操作 fs http buffer vent os运行node程序123456789101112console.log( `全局属性__dirname：${__dirname}` )console.log( `全局属性__filename：${__filename}` )console.log( `nodejs的单线程` )async function getData(d) { return new Promise(res =&gt; { setTimeout(function() { await getData(++d) console.log(d) }, 1000) })}getData(0)123456789101112131415161718//输出剩余内存所占百分比const os = require('os')//使用npm init -y &amp; npm i cpu-stat//实时获取cpu使用率const cpuStat = require('cpu-stat')const systemStat = async () =&gt; { let time = setTimeout(() =&gt; { const memory = os.freemem() / os.totalmem() * 100 console.log( `内存占用率${memory}%` ) cpuStat.usagePercent((err, percent) =&gt; { console.log( `cpu占用${percent}` ) }) clearTimeout(time) getMem() }, 1000)}systemStat()fs模块123456789101112131415const fs = require('fs')const data = fs.readdirSync(__dirname)data.forEach(async (item, index) =&gt; { try { if (/\\.js$|html$/g.test(item)) { let file = await fs.readFileSync( `${__dirname}/${item}` ) console.log(file) } } catch (e) { console.log(e) }})console.log(data)","link":"/2020/01/20/node%E5%AD%A6%E4%B9%A0/"},{"title":"【破解】office2010破解","text":"一、下载office安装包来自我告诉你复制这串代码打开迅雷或其他下载软件，本文也提供了百度网盘分享。1ed2k://|file|cn_office_professional_plus_2010_x64_515528.exe|912825496|B4F9B4635A6D440DD619592330D246B6|/百度云链接：https://pan.baidu.com/s/1QVcYaIr4Jtnc1jQJEYrHEg提取码：dcdj二、安装office2010打开刚刚下载的安装包数入以下激活码6QFDX-PYH2G-PPYFD-C7RJM-BBKQ8然后一直点确定就可以了三、下载破解工具工具来自胡萝卜周WARING!!!!!使用此软件需要退出关闭所有杀毒软件将文件解压出来后，右键点击以管理员身份运行点击激活 Microsoft office到这里激活就完成了！","link":"/2019/09/04/office2010%E7%A0%B4%E8%A7%A3/"},{"title":"【picgo】github图床配置","text":"下载picGO点击下载创建github仓库这一步简单了直接跳过创建github tokenhttps://github.com/settings/tokens注意 token只出现一次，最好复制，自己备份下,然后按照下图配置这张图是来自github的1[点击下载](https://github.com/Molunerfinn/PicGo/releases)仓库名：比如我的github账号名称时wxperia,建立的仓库名叫img,所以设置要填的仓库名就是Wxperia/img阿里云OSS到阿里云OSS 开启一个OSS bucket创建一个Accesskey进入授权界面进行授权,如果是博客使用的话，我还没发现能在访问时加 id和key的方法。所以我这里直接使用匿名账号，也就是所有人都可以看。还可以把你生成的图片地址解析到你的域名上（域名需要备案），这样就能直接用你的域名 + /blog/img20200109201752.png（图片地址）来访问图片了，然后在picGO设置中：设定自定义域名就行了，记得带https前缀这张图是来自阿里云OSS的1![](https://blog-status.oss-cn-beijing.aliyuncs.com/blog/img20200109200611.png)","link":"/2020/01/09/picGo+github%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/"},{"title":"【科学上网】trojan安装与使用","text":"简介原来是使用ssr进行翻墙，后来发现服务器IP特别容易被封,而且越用越慢，就开始考虑换种方式翻墙所以了解到了trojan;本教程记录了我自己搭建trojan + v2ray + BBRplus加速的过程。购买 VPS这里我选择的是Vultr 的3.5$/月的 VPS , 写这篇文章的时候 New York(NJ) 有这种配置的服务器，相对便宜些。而且支持支付宝，微信支付方式。还有一个优势就是 VPS 的 IP 被封了以后，可以新建一个实例，再把原来的实例注销就可以获取到一个新 IP 。*记得系统选择 Ubuntu 18.04 x64 + *有些系统无法安装 BBRPlus 加速影响使用体验为了保证 vpn 的速度，你可以多建立几个实例，分 ping 下选择延迟最低的那个。或者使用此命令进行测速wget https://v2rayssr.com/sh/gospeed.sh &amp;&amp; chmod +x gospeed.sh &amp;&amp; ./gospeed.shvps购买地址购买域名可以直接在阿里云上买个域名。然后将域名解析到自己的VPSVPS 和 域名 都购买完成后，需要下载一个 Xshell 连接你的实例xshell下载地址填写你的 VPS 的 IP填写 VPS 账户名 和 密码密码在vultr上进行查看安装所需要的环境apt-get update -y &amp;&amp; apt-get install curl -y ##Ubuntu/Debian 系统安装 Curl 方法yum update -y &amp;&amp; yum install curl -y ##Centos 系统安装 Curl 方法XZ 压缩工具apt-get install xz-utils #Debian/Ubuntu 安装 XZ 压缩工具命令yum install xz #CentOS 安装 XZ 压缩工具Trojan 一键脚本代码：bash &lt;(curl -s -L https://github.com/V2RaySSR/Trojan/raw/master/Trojan.sh)按提示把刚刚申请的域名填下，安装完成后，会展示一条下载地址，选中鼠标右键复制地址，并下载下来即可。打开下载的文件，找到 config.json 查看服务器端口和地址12345678910111213141516171819202122232425262728293031{ \"run_type\": \"client\", \"local_addr\": \"127.0.0.1\",//***服务器地址 \"local_port\": 1081,//***服务器端口 \"remote_addr\": \"xxx.xxx.com\",//这是你的域名 \"remote_port\": 443, \"password\": [ \"xxxxx\" //密码 ], \"log_level\": 1, \"ssl\": { \"verify\": true, \"verify_hostname\": true, \"cert\": \"fullchain.cer\", \"cipher_tls13\":\"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\",\"sni\": \"\", \"alpn\": [ \"h2\", \"http/1.1\" ], \"reuse_session\": true, \"session_ticket\": false, \"curves\": \"\" }, \"tcp\": { \"no_delay\": true, \"keep_alive\": true, \"fast_open\": false, \"fast_open_qlen\": 20 }}运行 start.bat 开启 trojan 服务下载V2ray配置 V2ray ：打开 V2ray 点击服务器菜单，选择编辑或添加 socks 服务，将上面的服务器地址，端口填上去就行了。密码用户名不需要填到这里就能开开心心的使用 v2ray 来上 google 、 youtube 了安装使用BBR加速注意 ：centos请不要使用 原版 bbr 以外的加速服务，有概率导致 vps 无法连接！！yum -y install wget ##CentOS Yum 安装 wgetapt-get install wget ##Debian Ubuntu 安装 wget一键安装 BBR/暴力 BBR/魔改 BBR/BBRplus/锐速 (Lotserver)四合一的脚本如下：wget -N –no-check-certificate “https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh如果出现以下界面，请选择No参考文章全系统支持，Trojan一键安装脚本，自动续签SSL证书，自动配置伪装网站，支持centos7+/debian9+/ubuntu16+VPS常用性能测试代码，VPS速度测试代码，VPS一键测试代码（测速代码中文版）Linux网络优化加速一键脚本","link":"/2020/02/18/trojan%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"【前端|TS】typescript学习笔记","text":"基本进制表示1234let decLiteral: number = 20 // 十进制let hexLiteral: number = 0x14 // 16进制let binaryLiteral: number = 0b10100 // 2进制let octalLiteral: number = 0o24 // 8 进制编译后的javascript1234var decLiteral = 20; // 十进制var hexLiteral = 0x14; // 16进制var binaryLiteral = 20; // 2进制var octalLiteral = 20; // 8 进制字符串类型123456//字符串let Username: string = 'bob'let age: string = '30'Username = `${age}`; // 模板字符串let sentence = `hello,my name is wap ${Username}`编译后的javascript12345//字符串var Username = 'bob';var age = '30';Username = \"\" + age; // 模板字符串var sentence = \"hello,my name is wap \" + Username;Array数组12345let alist: number[] = [1,2,3] // 数组定义方式1let blist: Array&lt;number&gt; = [1,2,3] //数组泛型let clist: [string,number] //元组clist = ['aaa',1]console.log(clist[0].substr(1))编译后的javascript12345var alist = [1, 2, 3]; // 数组定义方式1var blist = [1, 2, 3]; //数组泛型var clist; //元组 clist = ['aaa', 1];console.log(clist[0].substr(1));枚举类型12345678910enum Color { Red = 1, //Color[Color['Red'] = 1] = 'Red' //等价于 Color['Red'] = 1 Color['1'] = 'Red' Green = 2, Blue = 3}let colorName:string = Color[2];console.log(colorName)编译后的javascript12345678var Color;(function (Color) { Color[Color[\"Red\"] = 1] = \"Red\"; Color[Color[\"Green\"] = 2] = \"Green\"; Color[Color[\"Blue\"] = 3] = \"Blue\";})(Color || (Color = {}));var colorName = Color[2];console.log(colorName);any/void/never类型123456789101112131415161718192021222324252627282930313233//any 类型 谨慎使用//可以容纳所有类型let list: Array&lt;any&gt; = [1,true,'free'] //any类型，可以取消ts的类型检查// void 类型// 与any相反 指没有类型 只能赋予 undefined 和 nulllet unName: void = undefined unName = null// unName = 'aaa' //报错let num1: number = 3 num1 = null let list1: string[] = undefined //undefined 与null 是所有类型的子类它可以赋值给所有类型！// never 类型 函数无返回值function error(message: string): never { throw new Error(message)}function fail(): string{ return error('something failed');}function inifiniteLoop(): never{ for(;true;){ }}编译后的javascript1234567891011121314151617181920212223//any 类型 谨慎使用//可以容纳所有类型var list = [1, true, 'free']; //any类型，可以取消ts的类型检查// void 类型// 与any相反 指没有类型 只能赋予 undefined 和 nullvar unName = undefined;unName = null;// unName = 'aaa' //报错var num1 = 3;num1 = null;var list1 = undefined;//undefined 与null 是所有类型的子类它可以赋值给所有类型！// never 类型 函数无返回值function error(message) { throw new Error(message);}function fail() { return error('something failed');}function inifiniteLoop() { for (; true;) { }}object类型123456789101112//object 类型 declare function create(o: object | null):void; create({prop: 0}); //非原始类型和null undefined 可以被创建 create(null); create(undefined)/* 三个原始类型不能被create 创建 */// create(42);// create('string');// create(false);编译后的javascript12345678create({ prop: 0 });//非原始类型和null undefined 可以被创建create(null);create(undefined);/* 三个原始类型不能被create 创建 */// create(42);// create('string');// create(false);类型断言12345678//类型断言let value: any = 'this is a string'/* 类型的强转换，然后使用length *//* 直接使用length编辑器是不会自动补全的 *//* 实际上就是类型的强转 */let valLength: number = (&lt;string&gt;value).lengthlet valLengthAs: number = (value as string).length编译后的javascript1234567//类型断言var value = 'this is a string';/* 类型的强转换，然后使用length *//* 直接使用length编辑器是不会自动补全的 *//* 实际上就是类型的强转 */var valLength = value.length;var valLengthAs = value.length;","link":"/2019/09/08/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"vite+tsx项目构建","text":"vite + tsx 开发环境构建安装vite(略)https://cn.vitejs.dev/guide/#overviewtsx支持npm install @vitejs/plugin-vue-jsx –s-Dvue-router + vuex 引入npm install vuex@next –s创建以下目录文件storeactions.tsgetter.tsindex.tsmutations.tsstate.tsstate.ts123export default { count: 0}getter.ts123export const countAbs = (state) =&gt; { return Math.abs(state.count)}mutations.ts12345export default { setCount (state, count) { state.count = count }}actions.ts1234export function updateCount ({commit}, count) { const _count = count ++ commit('setCount', _count)}index.ts12345678910111213141516import { createStore, createLogger } from 'vuex'import state from './state'import mutations from './mutations'import * as getters from './getters'import * as actions from './actions'const debug = process.env.NODE_ENV !== 'production'export default createStore({ state, getters, mutations, actions, strict: debug, plugins: debug ? [createLogger()] : []})20210929…","link":"/2021/09/29/vite-tsx%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"title":"【JS】JS原型链","text":"javascript原型new 缺点，无法共享属性和方法，所以js设计者使用prototype解决原型解决共享方法和共享属性中。函数和对象的联系函数 也就是类，或构造方法函数是拥有prorotype123function Fun () { this.name = 'zs'}对象 （实例化之后）对象拥有的为__proto__12var person = new Fun()person.name // zs类的实例的原型，与1person.__proto__ === Fun.prorotype // true1Fun.prototype.constructor -&gt; // Fun构造函数1person.__proto__.__proto__ === Fun.prorotype.__proto__ -&gt; //Object原型new操作符具体做了什么创建一个对象 new Object()原型赋值，指向同一个原型对象对象.proto = Fun.prororype改变this指向fun.call(obj)原型链继承，让对象的属性和方法实现共享函数：prototype对象：proto","link":"/2021/01/31/%E3%80%90JS%E3%80%91JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"【JS】JS基础类型","text":"基本类型基本类型（string, number, boolean, undefined, null）引用类型：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型null 与undefined的区别undefined: 未定义null: 没有对象12typeof null // objecttypeof undefined // NaNjsvascript 作者先设计的null, 用来标示无的对象，空对象指针，转换为数值时为0；作者觉得一个空值最好是原始值，而null是一个对象，但是null是一个无法修复的错误所以又添加了undefined,undefined是一个标示无的原始值，转换为数值时为NaN基本类型和引用类型的区别基本类型存放在栈内存中可以通过变量直接访问是按值访问的，而引用类型存放在堆内存，通过栈内存存储的指针来访问。引用类型：每个对象都有唯一的标示，并且严格的等于自身，即使对象内部内容完全一致，二者也不会等","link":"/2021/01/31/%E3%80%90JS%E3%80%91JS%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"},{"title":"【docker】docker安装简单应用","text":"docker安装本机环境Ubuntu mate 20.04安装步骤更新现有软件包sudo apt update安装一些必备的软件环境sudo apt install apt-transport-https ca-certificates curl software-properties-common添加官方Docker的储存密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add将docker存储库添加到APT源sudo add-apt-repository “deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable”使用刚刚添加到APT库的docker软件包更新下sudo apt update确保要从docker存储库而不是默认的ubuntu库安装apt-cache policy docker-ce大概会看到这样的输出,格式基本一致，只是内容可能不同12345678910111213docker-ce:Installed:5:19.03.12~3-0~ubuntu-focalCandidate:5:19.03.12~3-0~ubuntu-focalVersion table:5:19.03.12~3-0~ubuntu-focal 500 500 https://download.docker.com/linux/ubuntu focal/stable arm64 Packages 100 /var/lib/dpkg/status 5:19.03.11~3-0~ubuntu-focal 500 500 https://download.docker.com/linux/ubuntu focal/stable arm64 Packages 5:19.03.10~3-0~ubuntu-focal 500 500 https://download.docker.com/linux/ubuntu focal/stable arm64 Packages 5:19.03.9~3-0~ubuntu-focal 500 500 https://download.docker.com/linux/ubuntu focal/stable arm64 Packages安装dockerapt install docker-ce查看docker状态systemctl status docker看到active就说明docker已经跑起来了123456 docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2020-08-29 09:34:12 CST; 5h 51min agoTriggeredBy: â docker.socket Docs: https://docs.docker.comMain PID: 5107 (dockerd)基本使用基本语法选项 命令 参数docker [option] [command] [arguments]查看所有的命令docker Output attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes","link":"/2020/08/29/%E3%80%90docker%E3%80%91docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"【docker】arm64树莓派docker安装","text":"【docker】树莓派docker安装系统：ubuntu-20.04.2-preinstalled-server-arm64+raspi设备：树莓派Pi4使用APT安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。1sudo apt-get update1234567sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ lsb-release \\ software-properties-common添加软件源的 GPG 密钥鉴于国内网络问题，强烈建议使用国内源。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。1234curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/raspbian/gpg | sudo apt-key add -# 官方源 不推荐！！# curl -fsSL https://download.docker.com/linux/raspbian/gpg | sudo apt-key add -添加 Docker 软件源向 sources.list 中添加 Docker 软件源：1add-apt-repository \"deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"其中$(lsb_release -cs)是个系统函数，可以自动获取当前ubuntu系统的版本，arm64对应的cpu的版本，我的主板是arm的，如果是电脑或者服务器注意是安装 amd64的，需要把arm64替换成amd64同理第四步，添加docker镜像源的时候，网址里面的域名也要看选择哪个源而变化的，上面举例的是docker官方的也可以使用阿里的源添加进去https://developer.aliyun.com/mirror/docker-ce更新apt索引1apt update安装最新版本的Docker CE1apt install docker-ce如果安装出现404或者没有找到包的情况，镜像源配置出错，或者是当前的镜像源没有同步到最新的版本，考虑换一个，如果是用官方的话，是最稳的，没有同步的情况，就是慢了一点检查docker安装状态1systemctl status docker","link":"/2021/02/21/%E3%80%90docker%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BEdocker%E5%AE%89%E8%A3%85/"},{"title":"【git】git操作流程","text":"","link":"/2021/08/30/%E3%80%90git%E3%80%91git%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"title":"hexo使用aplayer音乐播放器","text":"创建qq音乐歌单将歌单的地址复制出来将meting-js标签里的auto属性值设置为你的歌单的地址接下来啥都不用干，只需要把这段代码复制到你主题的公共目录下1234567891011121314151617&lt;div id=\"myAdlayer\"&gt;&lt;/div&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css\" integrity=\"sha256-uqQQGnDcmRKvhKwc5Vm4XT1GQ2oV6t1U0NR2N9tV+BQ=\" crossorigin=\"anonymous\" /&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js\" integrity=\"sha256-6Y7CJDaltoeNgk+ZftgCD9jLgmGv4xKUo8nQ0HgAwVo=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"&gt;&lt;/script&gt; &lt;meting-js auto=\" \" fixed=\"true\" type=\"playlist\" autoplay=\"false\" loop=\"all\" order=\"list\" volume=\"0.7\" list-folded=\"true\" &gt; &lt;/meting-js&gt;然后将上面这段代码直接复制到hexo博客的公共部分，如footer,header等。注意———如果直接放在footer,header最好开启fixed模式，否则会破坏原有布局。基本配置选项默认值描述idrequire歌曲 id / 播放列表 id / album id / 搜索关键字serverrequire歌曲来源: netease, tencent, kugou, xiami, baidutyperequire模式：song, playlist列表模式, album, search, artistautooptions单独的音乐链接: netease, tencent, xiamifixedfalse吸底模式minifalse迷你模式autoplayfalse自动播放theme#2980b9主题颜色loopall播放模式: all, one, noneorderlist列表播放模式: list, randompreloadauto预加载: none, metadata, autovolume0.7音量，会记录用户的设置mutextrue页面中有其他媒体播放时，aplayer是否停止播放lrc-type0歌词list-foldedfalse列表初始化状态是否折叠list-max-height340px列表最大宽度storage-namemetingjs本地存储key","link":"/2020/01/09/%E3%80%90hexo%E3%80%91%E4%BD%BF%E7%94%A8cdn%E5%8A%A0%E8%BD%BD%E5%8D%9A%E5%AE%A2%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E3%80%82/"},{"title":"【linux+科学上网】解决google机器人验证问题","text":"解决VPS多次使用google时，出现的机器人验证原理利用内网的某一台服务器，或公网的一台服务器做跳板，将所有的请求集中到一台机器上，再访问境外服务器，可以大大减少被谷歌机器人验证的频率。所以，在看本文之前，需要你已经部署了一台trojan服务端具体内容可以看这篇文章trojan的安装与使用准备工作工具【注意】**根据自己的系统下载不同的版本**trojan-go: 点击下载简介：使用Go实现的完整Trojan代理，与Trojan协议以及Trojan版本的配置文件格式兼容。安全，轻巧，易用。v2ray: 点击下载简介：V2Ray 是一个与 Shadowsocks 类似的代理软件，可以用来科学上网（翻墙）学习国外先进科学技术。windows v2ray客户端android v2ray客户端ios 需要自己找，爱莫能助xshelllrzsz简介：xshell文件上传工具环境ubuntu 20.04 mate arm64 (树莓派4B)安装trojan-go将下载好的包上传到服务器/usr/local文件夹下，并解压安装上传文件的工具sudo apt-get install lrzsz进入需要上传的目录，用鼠标将下载好的包上传上去cd /usr/localtar -xvf trojan-go-linux-arm.zip ./trojan使用trojan的安装与使用中，最终下载下来的trojan客户端中的config.json与fullchain.cer上传到服务器替换服务器/usr/local/trojan中的对应文件config.json12345678910111213141516171819202122232425262728293031{ \"run_type\": \"client\", \"local_addr\": \"127.0.0.1\", \"local_port\": 1080, \"remote_addr\": \"www.example.com\", \"remote_port\": 443, \"password\": [ \"your_password\" ], \"log_level\": 1, \"ssl\": { \"verify\": true, \"verify_hostname\": true, \"cert\": \"fullchain.cer\", \"cipher_tls13\":\"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\",\"sni\": \"\", \"alpn\": [ \"h2\", \"http/1.1\" ], \"reuse_session\": true, \"session_ticket\": false, \"curves\": \"\" }, \"tcp\": { \"no_delay\": true, \"keep_alive\": true, \"fast_open\": false, \"fast_open_qlen\": 20 }}cd /usr/local/trojan开启trojan-go./trojan-go -config ./config.json如果没有报错的话，就使用systemctl 添加自启动vim trojan.service将下面这部分内容复制进去123456789101112131415[Unit]Description=trojan-goAfter=network.target[Service]Type=simpleStandardError=journalUser=nobodyAmbientCapabilities=CAP_NET_BIND_SERVICEExecStart=/usr/local/trojan/trojan-go -config /usr/local/trojan/config.jsonExecReload=/bin/kill -HUP $MAINPIDRestart=on-failureRestartSec=3s[Install]WantedBy=multi-user.target注册服务mv trojan.service /lib/systemd/systemsystemctl start trojan查看运行状态systemctl status trojan出现下面这样的结果就算运行成功了1234567● trojan.service - trojan-go Loaded: loaded (/lib/systemd/system/trojan.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2020-09-05 13:36:01 CST; 52min ago Main PID: 69188 (trojan-go) Tasks: 7 (limit: 4206) CGroup: /system.slice/trojan.service └─69188 /usr/local/trojan/trojan-go -config /usr/local/trojan/config.json安装v2ray进入刚刚上传包的目录cd /usr/local解压到 v2ray 目录unzip v2ray-linux-arm64-v8a.zip -d ./v2ray进入v2ray 修改config文件cd /usr/local/v2rayvim config.json将里面的内容删除替换成以下内容 【注意】需要先删掉注释！！！！！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136{ \"policy\": { \"system\": { \"statsInboundUplink\": true, \"statsInboundDownlink\": true } }, \"log\": { \"access\": \"\", \"error\": \"\", \"loglevel\": \"warning\" }, // 本地代理端口1081,待会本地填的就是这个端口 \"inbounds\": [ { \"tag\": \"proxy\", \"port\": 1081, \"listen\": \"0.0.0.0\", \"protocol\": \"socks\", \"sniffing\": { \"enabled\": true, \"destOverride\": [ \"http\", \"tls\" ] }, \"settings\": { \"auth\": \"noauth\", \"udp\": true, \"ip\": null, \"address\": null, \"clients\": null }, \"streamSettings\": null }, { \"tag\": \"api\", \"port\": 50262, \"listen\": \"127.0.0.1\", \"protocol\": \"dokodemo-door\", \"sniffing\": null, \"settings\": { \"auth\": null, \"udp\": false, \"ip\": null, \"address\": \"127.0.0.1\", \"clients\": null }, \"streamSettings\": null } ], // 连接trojan-go的端口1080 \"outbounds\": [ { \"tag\": \"proxy\", \"protocol\": \"socks\", \"settings\": { \"vnext\": null, \"servers\": [ { \"email\": null, \"address\": \"127.0.0.1\", \"method\": null, \"ota\": false, \"password\": null, \"port\": 1080, \"level\": 1, \"users\": null } ], \"response\": null }, \"streamSettings\": { \"network\": \"tcp\", \"security\": null, \"tlsSettings\": null, \"tcpSettings\": null, \"kcpSettings\": null, \"wsSettings\": null, \"httpSettings\": null, \"quicSettings\": null }, \"mux\": { \"enabled\": false, \"concurrency\": -1 } }, { \"tag\": \"direct\", \"protocol\": \"freedom\", \"settings\": { \"vnext\": null, \"servers\": null, \"response\": null }, \"streamSettings\": null, \"mux\": null }, { \"tag\": \"block\", \"protocol\": \"blackhole\", \"settings\": { \"vnext\": null, \"servers\": null, \"response\": { \"type\": \"http\" } }, \"streamSettings\": null, \"mux\": null } ], \"stats\": {}, \"api\": { \"tag\": \"api\", \"services\": [ \"StatsService\" ] }, \"dns\": null, \"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ { \"type\": \"field\", \"port\": null, \"inboundTag\": [ \"api\" ], \"outboundTag\": \"api\", \"ip\": null, \"domain\": null } ] }}启动v2ray/usr/local/v2ray/v2ray -c /usr/local/v2ray/config.json注册服务v2ray 自带service文件，就在v2ray下的systemd/system下vim /usr/local/v2ray/systemd/system/v2ray.servcie123456789101112131415[Unit]Description=V2Ray ServiceDocumentation=https://www.v2fly.org/After=network.target nss-lookup.target[Service]User=nobodyCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICEAmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICENoNewPrivileges=trueExecStart=/usr/local/v2ray/v2ray -config /usr/local/v2ray/config.jsonRestart=on-failure[Install]WantedBy=multi-user.target注册服务mv /usr/local/v2ray/systemd/system/v2ray.servcie /lib/systemd/system启动v2raysystemctl start v2ray给两个服务开启自启动systemctl enable trojansystemctl enable v2ray配置window下的v2ray安心上网","link":"/2020/09/05/%E3%80%90linux-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E3%80%91%E8%A7%A3%E5%86%B3google%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/"},{"title":"【linux】frp内网穿透","text":"linux内网穿透使用frp实现内网穿透，达到通过外网ip访问内部服务的目的准备工作外网服务器*1 没有特别的配置需求下载frp【注意】：需要根据服务端和客户端的系统下载两个不同的版本frp安装【注意】服务端指的外网服务器，客户端指的是内网服务器服务器端部署将下载的包上传到服务器解压下载的frp包tar -xvf frp_0.33.0_darwin_amd64.tar.gz修改文件夹名字mv frp_0.33.0_darwin_amd64 frp进入修改的文件夹cd frpvim frps.ini修改配置文件123456789101112[common]# frp隧道绑定的端口bind_port = 7000# http代理的端口vhost_http_port = 6001# 自定义的tokentoken = xxxxx# 管理面板的端口账号和密码dashboard_port = 7272dashboard_user = admin# 密码记得修改dashboard_pwd = admin启动frp./frps -c ./frps.ini开启frp服务端自启动cd /usr/lib/systemd/systemvim frps.service123456789101112[Unit]Description=frps service# 网络连接成功时启动After=network.target syslog.targetWants=network.target[Service]Type=simple# 启动服务的命令（此处写你的frps的实际安装目录）ExecStart=/usr/local/frps/frps -c /usr/local/frps/frps.ini[Install]WantedBy=multi-user.target保存后执行systemctl start frps其他命令停止：systemctl stop frps客户端部署步骤都一样，只是配置文件不同这次我们修改frpc.ini1234567891011121314151617181920# frpc.ini[common]# 服务端地址server_addr = x.x.x.x# 服务端隧道端口server_port = 7000# token 与服务端一致token = xxxxx[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22# 外网访问时连接时使用的端口 ssh -oPort=6000 test@x.x.x.xremote_port = 6000[web]type = httplocal_port = 80# 如果公网服务器在国内这个域名一定要备案custom_domains = www.example.com之后开启开机自启cd /usr/lib/systemd/systemvim frpc.service123456789101112[Unit]Description=frapc service# 网络连接后After=network.target syslog.targetWants=network.target[Service]Type=simple# 启动服务的命令（此处写你的frps的实际安装目录）ExecStart=/usr/local/frpc/frpc -c /usr/local/frpc/frpc.ini[Install]WantedBy=multi-user.target这样配置好了之后就可以在外网访问自己的服务器了ssh -oPort=6000 user@x.x.x.x注意：两台服务器，使用的端口记得开起来！否则会连接失败！","link":"/2020/08/29/%E3%80%90linux%E3%80%91frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"title":"【linux】github-webhooks实现自动部署","text":"涉及知识点nodejsgithublinux shellnginxpm2实现原理利用webhook通知服务器，仓库有push或者其他操作，服务得到通知后利用sh脚本拉取最新的代码并完成部署新建一个privte库因为webhook需要一个secret字段来验证身份，所以需要建立private库保证安全！将仓库clone到本地，进入到项目目录下执行：npm init –ynpm i github-webhook-handler新建一个auto_build.js文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546var http = require('http')var spawn = require('child_process').spawnvar createHandler = require('github-webhook-handler')// 下面填写的myscrect跟github webhooks配置一样，下一步会说；path是我们访问的路径// secret 对应webhook里的secret字段 path就是接口访问的地址var handler = createHandler({ path: '/auto_build', secret: '这里写你的secret后面用得到！' })http.createServer(function (req, res) { handler(req, res, function () { res.statusCode = 404 res.end('no such location') }) console.log('listen on 6666')}).listen(6666)handler.on('error', function (err) { console.error('Error:', err.message)})// 监听到push事件的时候执行我们的自动化脚本handler.on('push', function (event) { console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref) // 这个路径就是需要执行的sh脚本的路径 runCommand('sh', ['./auto_build.sh'], function (txt) { console.log(txt) })})function runCommand (cmd, args, callback) { var child = spawn(cmd, args) var resp = '' child.stdout.on('data', function (buffer) { resp += buffer.toString() }) child.stdout.on('end', function () { callback(resp) })}// 由于我们不需要监听issues，所以下面代码注释掉// handler.on('issues', function (event) {// console.log('Received an issue event for %s action=%s: #%d %s',// event.payload.repository.name,// event.payload.action,// event.payload.issue.number,// event.payload.issue.title)// });新建一个auto_build.sh文件，写入以下内容12345678910111213#! /bin/bash# 项目地址，注意要是绝对路径，防止不必要的错误SITE_PATH='project-path'USER='admin'USERGROUP='admin'cd $SITE_PATHgit reset --hard origin/mastergit clean -fgit pullgit checkout mastercnpm run buildchown -R $USER:$USERGROUP $SITE_PATH将这个项目push到github中【注意】（这个操作需要你先将服务器的sshkey添加到github），或者直接上传到你的服务器，使用pm2启动如果没有pm2请先安装npm install -g pm2pm2 start auto_build.jsnginx反向代理nginx.conf 添加以下配置123location /auto_build { proxy_pass http://127.0.0.1:6666; }github webhooks 配置进入需要配置自动部署的库，点击最左边的settings选项，Payload URL 接口访问地址Content type 选jsonsecret 就是之前写的 secret两个要保持一致测试push不出问题的话，现在仓库的push能被监听了","link":"/2020/08/31/%E3%80%90linux%E3%80%91github-webhook%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"title":"【nodejs】reuqire源码分析","text":"require 源码阅读过程中的一些思考CommonJS模块加载的流程require 如何加载内置模块require 如何加载node_modules模块require为什么会将非js/json/node文件视为js文件加载？Module对象id: 源码文件路径：如 /usr/xxxx/index.jspath: 源码文件对应的文件夹，通过path.dirname(id)生成exports: 模块输出的内容，默认为{}parent: 父模块信息filename: 源码文件路径loaded: 是否已经加载完成children: 子模块对象集合paths: 模块查询范围Require的基本流程(CommonJS模块加载的流程)1require('./local')以上代码为例子，require会调用原型链上的mod.require(path)方法来进入模块的加载流程。从以下代码就不难看出，require只支持string类型，如果加载的是其他类型则会抛出异常1234567891011121314151617181920Module.prototype.require = function(id) { // 判断id是否为String validateString(id, 'id'); // 这里是抛出一个自定义的错误 if (id === '') { throw new ERR_INVALID_ARG_VALUE('id', id, 'must be a non-empty string'); } // 每新加载一个模块，都会是的requireDepth++ requireDepth++; try { // id作为require的地址，this，作为parent, return Module._load(id, this, /* isMain */ false); } finally { // 加载完成后则requireDepth-- // 当requireDepth为0时，则说明加载完成 requireDepth--; }};module.load 函数,如果是主模块的话，isMain则会是true,会将我们使用node时传入的第一个值，作为path（id）来加载执行,因为我们是在另一个js文件中引用的此文件来进行调试的，所以 走的是非主模块的逻辑12345678910function executeUserEntryPoint(main = process.argv[1]) { const resolvedMain = resolveMainPath(main); const useESMLoader = shouldUseESMLoader(resolvedMain); if (useESMLoader) { runMainESM(resolvedMain || main); } else { // Module._load is the monkey-patchable CJS module loader. Module._load(main, null, true); }}load会先判断是存在父级js,如果存在则会将父子的地址拼接，生成最终需要加载的文件地址，之后再检查此模块是否存在缓存如果有缓存则继续检查是否已经加载完成，加载完成则直接返回js文件中的exports对象，否则通过getExportsForCircularRequire从缓存的js文件中尝试获取他的exports对象12345678910111213141516171819202122232425Module._load = function(request, parent, isMain) { let relResolveCacheIdentifier; // 判断是否存在父级元素 if (parent) { debug('Module._load REQUEST %s parent: %s', request, parent.id); // Fast path for (lazy loaded) modules in the same directory. The indirect // caching is required to allow cache invalidation without changing the old // cache key names. // 这里将主模块的目录，拼接上我们请求的目录， relResolveCacheIdentifier = `${parent.path}\\x00${request}`; // 生成最终的文件 const filename = relativeResolveCache[relResolveCacheIdentifier]; if (filename !== undefined) { const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) { updateChildren(parent, cachedModule, true); if (!cachedModule.loaded) return getExportsForCircularRequire(cachedModule); return cachedModule.exports; } delete relativeResolveCache[relResolveCacheIdentifier]; } }}如果没有父级js则直接通过Module._resolveFilename来实现文件的加载，这个方法首先会判断是否为node原生模块然后判断是否为相对路径，无论路径是否存在，最终都会通过_resolveLookupPaths来找到正确的路径并返回，各种类型，内置模块，node_modules模块，本地模块，都需要通过_resolveFilename生成的地址字符串来区分，node_modules，最终还是会回到本地模块的加载流程。如果模块不存在，_resolveFilename中的_resolveLookupPaths中，会返回false，抛出错误。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Module._resolveFilename(request, parent, isMain);Module._resolveFilename = function(request, parent, isMain, options) { if (StringPrototypeStartsWith(request, 'node:') || NativeModule.canBeRequiredByUsers(request)) { return request; } let paths; if (typeof options === 'object' &amp;&amp; options !== null) { if (ArrayIsArray(options.paths)) { //判断是否为相对路径 const isRelative = StringPrototypeStartsWith(request, './') || StringPrototypeStartsWith(request, '../') || ((isWindows &amp;&amp; StringPrototypeStartsWith(request, '.\\\\')) || StringPrototypeStartsWith(request, '..\\\\')); if (isRelative) { paths = options.paths; } else { const fakeParent = new Module('', null); paths = []; for (let i = 0; i &lt; options.paths.length; i++) { const path = options.paths[i]; fakeParent.paths = Module._nodeModulePaths(path); const lookupPaths = Module._resolveLookupPaths(request, fakeParent); for (let j = 0; j &lt; lookupPaths.length; j++) { if (!ArrayPrototypeIncludes(paths, lookupPaths[j])) ArrayPrototypePush(paths, lookupPaths[j]); } } } } else if (options.paths === undefined) { paths = Module._resolveLookupPaths(request, parent); } else { throw new ERR_INVALID_ARG_VALUE('options.paths', options.paths); } } else { paths = Module._resolveLookupPaths(request, parent); } if (parent?.filename) { if (request[0] === '#') { const pkg = readPackageScope(parent.filename) || {}; if (pkg.data?.imports != null) { try { return finalizeEsmResolution( packageImportsResolve(request, pathToFileURL(parent.filename), cjsConditions), request, parent.filename, pkg.path); } catch (e) { if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request); throw e; } } } }require 流程总结：引用Sting校验使用relativeResolveCache[relResolveCacheIdentifier]来查询缓存Module.cache[filename]查询缓存模块Module._resolveFilename 查询模块的真实路径new Module实例化Module对象module.load(filename)加载模块findLongestRegisteredExtension获取文件后缀Module._extensions[extension](this, filename) 解析模块并执行module._compile编译模块代码compileFunction将模块生成可执行函数exports,require,module,filename,dirname生成入参compiledWrapper.call执行模块函数return module.exports输出模块返回结果","link":"/2022/01/14/%E3%80%90nodejs%E3%80%91reuqire%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"【node】node爬虫实践","text":"完整代码已经上传到我的githubSpy-tools百度图片爬取核心代码百度搜索获取图片时，页面加载方式是下拉加载，为了克服这个问题，就了解了下puppeteer这个库，这个库能够打开一个沙盒浏览器，然后使用代码模拟正常的操作，点击，输入之类的，有点类似于auto.js。爬虫核心apipage.$() 获取页面中的元素，与jquery一致page.evaluate(()=&gt;{},element) 相当于当前打开页面的控制台，element默认为window，这个方法是获取页面内容的关键page.goto(URL) 打开某个网页page.on() 监听页面中调用的方法 比如consolesleep方法用于控制等待时间，防止网站反爬1234567891011class sleep{ async sleep(time){ console.log(`now to sleep ${time}ms`); return new Promise( next=&gt; { setTimeout(()=&gt; { next(); }, time); }) };}module.exports = new sleep();模仿真人下拉刷新1234567891011121314151617181920212223 // 模拟滚动，获取足够的图片 const scrollTimer = page.evaluate(() =&gt; { //这个作用域的this不能改变,否则无法正常获取页面元素 const DOWLOAD_SIZE = 1000; // 一次性需要下载图片的数量 return new Promise((resolve, reject) =&gt; { let totalSize = 0 let totalHeight = 0 let distance = 600 let timer = setInterval(() =&gt; { window.scrollBy(0, distance) totalHeight += distance let imgList = Array.from(document.getElementsByClassName('imgitem')) // 处理图片数量不够的情况 let documentScrollHeight = document.body.scrollHeight let isMaxed = totalHeight &gt;= documentScrollHeight totalSize = imgList.length if(totalSize &gt;= DOWLOAD_SIZE || isMaxed){ clearInterval(timer) resolve() } }, 200) })})获取页面内的数据1234567891011121314151617const data = await page.evaluate( async () =&gt; { let ret = [] class imgData { constructor(title, url) { this.title = title this.url = url } } let itemlist = document.getElementsByClassName('imgitem') Array.from(itemlist).forEach(li =&gt; { let title = li.getAttribute(\"data-title\") let img = li.getElementsByClassName('main_img')[0] let url = img.getAttribute('src') ret.push(new imgData(title, url)) }) return ret })下载123456789101112131415161718192021222324252627282930let request = require(\"request\");let fs = require(\"fs\"); class Ut { static downImg(opts = {}, path = '') { return new Promise((resolve, reject) =&gt; { request .get(opts) .on('response', (response) =&gt; { // console.log(\"img type:\", response.headers['content-type']) }) .pipe(fs.createWriteStream(path)) .on(\"error\", (e) =&gt; { // console.log(\"pipe error\", e) resolve(''); }) .on(\"finish\", () =&gt; { // console.log(\"finish\"); resolve(\"ok\"); }) .on(\"close\", () =&gt; { // console.log(\"close\"); }) }) };} module.exports = Ut;一个一个下载1234567891011121314151617181920212223let len = data.length async function getData(index,list) { if(!list[index]) { return }else { let item = list[index] let url = item.url let path = `${FILE_PATH}/${index}.jpg`; if (/http/g.test(url)) { let opts = { url: url, }; log(chalk.green(`正在下载第${index}张共${len}张...`)) await Ut.downImg(opts, path); log(chalk.green(`正在下载第${index}张下载成功`)) } index ++ await getData(index,list) } } if (len) { await getData(0,data) }","link":"/2020/09/26/%E3%80%90node%E3%80%91node%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5/"},{"title":"科学上网","text":"一、购买vpsVultr1、一般情况下，买新加坡的节点会好些，有3.5$一个月的，但是很难开出有用的ip。这里我选择的是 centos 7 x64的系统 5$ 一个月 1cup 1g 1000GB，可能你看到的时候价格会不同，也可以选择其他城市机房3.5$一个月的vps 配置只有这个的一半2、等待vps初始化完成过后，打开服务器详情3、这三个从上到下依次是服务器ip用户名密码二、下载xshell连接vps安装ssr服务端xshell打开xshell 选择新建会话第一次连接会弹出很多对话框，点击确定就好三、部署SSR服务端1、安装加密依赖（chacha20 加密支持）yum groupinstall “Development Tools” -yyum install wget -y2、下载libsodium&lt;1&gt; 从官网下载：wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz&lt;2&gt; 从 github 下载（其中 1.0.10 是 libusodium 的版本号，可以改成最新的）：wget https://github.com/jedisct1/libsodium/releases/download/1.0.10/libsodium-1.0.10.tar.gz3、解压&lt;1&gt;官网下载的：tar xzvf LATEST.tar.gz&lt;2&gt;github 下载的：tar xzvf libsodium-1.0.10.tar.gz4、生成配置文件cd libsodium*./configure5、编译并安装make -j8 &amp;&amp; make install6、添加运行库位置并加载运行库echo /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.confldconfig到这里输入cd ~ 按回车再进行下一步！四、安装shadowsock一键安装脚本：wget -N –no-check-certificate https://oss.mzyyun.com/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh备用下载地址（上面的链接无法下载，就用这个）：1、命令执行完后会出现以下界面选择1、安装ShadowsocksR按照以下配置进行选择，最后出现的什么限制类的设置，自己按需要设置就好。端口可以随意但是注意不要出现端口冲突请输入要设置的ShadowsocksR账号 端口 (默认: 2333): 45484请输入要设置的ShadowsocksR账号 密码 (默认: doub.io): 66666请选择要设置的ShadowsocksR账号 加密方式1234567891011121314151617181920212223 1. none[注意] 如果使用 auth_chain_a 协议，请加密方式选择 none，混淆随意(建议 plain) 2. rc4 3. rc4-md5 4. rc4-md5-6 5. aes-128-ctr 6. aes-192-ctr 7. aes-256-ctr 8. aes-128-cfb 9. aes-192-cfb10. aes-256-cfb11. aes-128-cfb812. aes-192-cfb813. aes-256-cfb814. salsa2015. chacha2016. chacha20-ietf[注意] salsa20/chacha20-*系列加密方式，需要额外安装依赖 libsodium ，否则会无法启动ShadowsocksR !选择 16. chacha20-ietf请选择要设置的ShadowsocksR账号 协议插件12345671. origin2. auth_sha1_v43. auth_aes128_md54. auth_aes128_sha15. auth_chain_a6. auth_chain_b[注意] 如果使用 auth_chain_a 协议，请加密方式选择 none，混淆随意(建议 plain)选择 2. auth_sha1_v4是否设置 协议插件兼容原版(_compatible)？[Y/n]n请选择要设置的ShadowsocksR账号 混淆插件123456781. plain2. http_simple3. http_post4. random_head5. tls1.2_ticket_auth[注意] 如果使用 ShadowsocksR 加速游戏，请选择 混淆兼容原版或 plain 混淆，然后客户端选择 plain，否则会增加延迟 !另外, 如果你选择了 tls1.2_ticket_auth，那么客户端可以选择 tls1.2_ticket_fastauth，这样即能伪装又不会增加延迟 !如果你是在日本、美国等热门地区搭建，那么选择 plain 混淆可能被墙几率更低 !选择 1. plain后面出现的几个选项直接安回车就行了最后成功了会出现以下信息我这里删除了部分关键信息123456789101112131415161718192021=================================================== ShadowsocksR账号 配置信息： I P : 000.000.000.000 端口 : 密码 : 加密 : chacha20-ietf 协议 : auth_sha1_v4 混淆 : plain 设备数限制 : 4 单线程限速 : 0 KB/S 端口总限速 : 0 KB/S SSR 链接 : ssr://MTk4LjEzLjUxLjE3ODo1MTA0NTphdXRoX3NoY... SSR 二维码 : http://doub.pw/qr/qr.php?text=ssr://MTk4LjEzLjUxLjE3ODo1MTA0NTphdXRoX3NoYT... 提示: 在浏览器中，打开二维码链接，就可以看到二维码图片。 协议和混淆后面的[ _compatible ]，指的是 兼容原版协议/混淆。===================================================最后一步，下载客户端。PC端SSR客户端：SSR_PCandroid：SSR_androidmac: SSR_macos五、SSR 加速与维护平时可以使用 bash ssr.sh 来打开控制面板1、安装谷歌bbr加速wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh实测安装后能上youtube看4k (前提是你的水管能够看国内的4k)2、ssr失效怎么办？首先，打开cmd ping自己服务器的ip通不通，如果不通。说明你的ip已经被墙了！只能Destory这个vps后再开一个，会重新获得一个ip vultr 就是这点好，封了一个IP 再开就行了。如果ip还能ping得通,单独修改下端口就行了。","link":"/2019/08/29/%E3%80%90trojan%E3%80%91%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"title":"【vue】实现项目打包完成后修改接口地址","text":"打包完成情况下修改后端接口地址项目前端和后端的服务并不部署在一块，并且服务器可能是没有外网环境的，所以需要能够在项目已经打包的情况下去修改前端请求后台的接口地址，这样就不用一个地址一个版本了步骤1、保证配置文件不被webpack打包2、使用axios获取配置IP的json文件3、使用axios请求拦截器在发送请求前插入动态获取的接口地址4、动态获取Ip并且缓存起来，减少请求次数代码保证配置文件不被webpack打包vue-cli 默认不打包public中的文件，所以在public下新建一个ip.config.json文件，这样配置文件就不会被打包，而且使用nginx或者其他web容器代理后可以直接使用localhost + ‘/ip.config.json’访问ip.config.json1234{ \"IP\":\"http://localhost:8443\", \"DEV_IP\":\"http://192.168.3.58:8443\"}使用axios获取地址配置文件并且缓存试过使用import，require确实能获取到配置的地址，但是也是硬写到代码中的，打包完成后修改ip.config.json并不能修改接口地址，这里返回一个方法让外部可以直接调用获取ip，缓存可以考虑存进localstorage,毕竟项目部署完了，后台请求地址肯定不会天天换的。12345678910111213141516import axios from 'axios'let config = nullexport default async function () { // 检查是否已经获取过了 if (config === null) { const data = await axios.get('ip.config.json') config = data.data } // 检查是否为生产模式 const isProduction = process.env.NODE_ENV === 'production' const baseIp = isProduction ? config.IP : config.DEV_IP const base = { ip: baseIp } return base}使用axios请求拦截器在发送请求前插入动态获取的接口地址因为是异步获取的，所以只能在拦截器里去修改，如果使用axios.defaults.baseUrl 来修改还是会比较麻烦的。12345678910111213141516171819202122// 再次缓存let cacheIp = ''const instance = axios.create({ timeout: 1000 * 12 })instance.interceptors.request.use( async config =&gt; { const url = config.url if (cacheIp === '') { cacheIp = await base() } // 地址匹配正则 const httpReg = /(https?|ftp|file):\\/\\/[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]/ if (!httpReg.test(url)) { // 检查是否已经获取了cacheIp // 如果获取了，就不再次获 config.url = cacheIp.ip + config.url } return config }, error =&gt; { return Promise.error(error) })效果这样就能在项目打包后，还能修改前端请求后端的地址。","link":"/2021/01/08/%E3%80%90vue%E3%80%91%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%AE%8C%E6%88%90%E5%90%8E%E4%BF%AE%E6%94%B9%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80/"},{"title":"【vue】解耦模块之间的语言文件","text":"引入vue-i18n项目UI用的是element, 所以需要连element一起把多语言给做了12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import VueI18n from 'vue-i18n'import messages from './langs'import ElementUI from 'element-ui'import enlocale from 'element-ui/lib/locale/lang/en'import cnlocale from 'element-ui/lib/locale/lang/zh-CN'import mergeWith from 'lodash/mergeWith'Vue.use(VueI18n)Vue.use(ElementUI, { i18n: (key, value) =&gt; i18n.t(key, value)})// 合并element和自己设置的公共多语言文件let merageEn = mergeWith(messages.en, enlocale)let merageCn = mergeWith(messages.cn, cnlocale)const i18n = new VueI18n({ locale: 'cn', messages: { cn: merageCn, en: merageEn }, silentTranslationWarn: true})// 扩展i18n动态修改语言包的方法// 添加新的国际化i18nObji18n.addNewLang = function (lang) { // 合并之前的旧的国际化类 merageEn = mergeWith(merageEn, lang.en) merageCn = mergeWith(merageCn, lang.cn) // i18n对象热更新 i18n.setLocaleMessage('en', merageEn) i18n.setLocaleMessage('cn', merageCn)}export default i18n在main.js文件中引入1234567import i18n from '@/common/i18n/i18n.js'new Vue({ router, store, i18n, render: h =&gt; h(App) }).$mount('#app')基本使用i18n 对象结构1234567891011121314151617181920212223242526272829303132333435{ // 英文相关字段 en: { // 'en' Locale key1: \"this is message1\", // 基本的 nested: { // 嵌套 message1: \"this is nested message1\" }, errors: [ // 数组 \"this is 0 error code message\", { // 数组嵌套对象 \"internal1\": \"this is internal 1 error message\" }, [ // 数组嵌套数组 \"this is nested array error 1\" ] ] }, // 中文相关字段 cn: { // 'cn' Locale // ... key1: \"这是一条message1\", // 基本的 nested: { // 嵌套 message1: \"这是嵌套的message1\" }, errors: [ // 数组 \"这是0错误代码消息\", { // 数组嵌套对象 \"internal1\": \"这是内部1错误消息\" }, [ // 数组嵌套数组 \"这是嵌套数组错误1\" ] ] }}在 vue 单文件中使用1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;!-- 基本的 --&gt; &lt;p&gt;{{ $t('key1') }}&lt;/p&gt; &lt;!-- 嵌套 --&gt; &lt;p&gt;{{ $t('nested.message1') }}&lt;/p&gt; &lt;!-- 数组 --&gt; &lt;p&gt;{{ $t('errors[0]') }}&lt;/p&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;p&gt;{{ $t('errors[1].internal1') }}&lt;/p&gt; &lt;!-- 数组嵌套数组 --&gt; &lt;p&gt;{{ $t('errors[2][0]') }}&lt;/p&gt;&lt;/div&gt;&lt;!-- 输出以下内容 --&gt;&lt;div id=\"app\"&gt; &lt;!-- 基本的 --&gt; &lt;p&gt;this is message1&lt;/p&gt; &lt;!-- 嵌套 --&gt; &lt;p&gt;this is nested message1&lt;/p&gt; &lt;!-- 数组 --&gt; &lt;p&gt;this is 0 error code message&lt;/p&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;p&gt;this is internal 1 error message&lt;/p&gt; &lt;!-- 数组嵌套数组 --&gt; &lt;p&gt;this is nested array error 1&lt;/p&gt;&lt;/div&gt;在 vue 单文件 js 代码中使用123456789101112131415161718192021222324252627282930313233343536373839404142434445const lang = { en: { // 'en' Locale // 这个变量需要用自己的模块名，防止与其他模块冲突，如果有冲突addNewLang会抛出错误 modelName: { //... 模块需要用到的变量名 }, }, // 中文相关字段规则与上面的一致 cn: { // 'cn' Locale // ... key1: '这是一条message1', // 基本的 nested: { // 嵌套 message1: '这是嵌套的message1', }, errors: [ // 数组 '这是0错误代码消息', { // 数组嵌套对象 internal1: '这是内部1错误消息', }, [ // 数组嵌套数组 '这是嵌套数组错误1', ], ], },}export default { created() { // 加载对应的文件 this.$i18n.addNewLang(lang) }, data() { return { key1: this.$t('message.key1') } },}// 输出：//cn: 这是一条message1//en: this is message1在普通 js 文件中使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 引入 i18n模块import i18n from '@/common/i18n/i18n.js'// 创建i18n规则const lang = { en: { // 'en' Locale // 这个变量需要用自己的模块名，防止与其他模块冲突，如果有冲突addNewLang会抛出错误 modelName: { //... 模块需要用到的变量名 }, }, // 中文相关字段规则与上面的一致 cn: { // 'cn' Locale // ... key1: '这是一条message1', // 基本的 nested: { // 嵌套 message1: '这是嵌套的message1', }, errors: [ // 数组 '这是0错误代码消息', { // 数组嵌套对象 internal1: '这是内部1错误消息', }, [ // 数组嵌套数组 '这是嵌套数组错误1', ], ], },}// 加载此规则i18n.addNewLang(lang)// 使用const test = i18n.t('key1')// console.log(test)// 输出：// cn: \"这是一条message1\"// en: \"this is message1\"","link":"/2020/12/29/%E3%80%90vue%E3%80%91%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6/"},{"title":"【前端】ts深入","text":"深度使用ts接口实现使用接口定义一个对象1234567891011121314interface TestInterface { a: string, b: string,// 可选属性 [test: string]: string // 这种写法跟前者不能共存 // test?:string}// 使用const obj: TestInterface = { a: '1', b: '2'}使用可选属性，创建一个可索引对象12345// 可索引类型// 实现的对象可以有任意的属性interface RandomMap { [propName: string]: string}使用接口定义一个方法下面的定义的方法中1234567891011121314151617// Foo 方法无返回参数interface Foo { (a: string): void}// isNumber返回一个Number参数interface isNumber { (a: any): boolean}const foo: Foo = function (a) { }const isNum:isNumber = function (a) { return !Number.isNaN(parseInt(a))}泛型当一个接口需要根据外部类型动态调整，比如vue的Props,或者当一个方法的返回值与传入的参数的类型有关联时就可使用泛型来处理直接写在方法上12345678// 泛型function echo&lt;T&gt;(arg: T): T { return arg}// 方法泛型function swap&lt;T,U&gt;(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]]}通过接口来实现1234567891011121314interface Swap { &lt;U, T&gt;(tuple: [U, T]): [T, U]}interface NoSwap { &lt;U, T&gt;(tuple: [U, T]): [U, T]}// 实现接口const swapFunc:Swap = function (a) { return [a[1], a[0]]}const noSwapFunc: NoSwap = function (a) { return [a[0], a[1]]}泛型在异步请求上的使用, 用于确定返回值的格式类型1234567891011121314interface WidthApi { &lt;T&gt;(data: string): Promise&lt;T&gt;}interface GitHubResp { name: string, id: number}const api:WidthApi = function &lt;GitHubResp&gt;(a:string): Promise&lt;GitHubResp&gt; { return new Promise((resolve, reject)=&gt;{ })}api&lt;GitHubResp&gt;('1').then(res=&gt;{ console.log(res)})联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。简单的例子1234567891011121314151617let myFa: string|number;interface name { name: string}interface age { age: string | number}type Person = age &amp; name// Person 内会存在 name以及age属性let p1:Person = { name: 'xiaoming', age: '18'}lookup types12345678910111213141516interface in3 { name: string, key: string, id: number}// 利用泛型和对类型key的遍历，实现一个将所有属性转换为只读属性的接口type ToReadOnly&lt;T&gt; = { readonly [p in keyof T]: T[p]}// 将传入的类型转换为可选类型type ToOption&lt;T&gt; = { [p in keyof T]?: T[p]}泛型约束extends 来表示某个泛型必须是 T 的子集1234567891011121314151617interface IWidthLength { length: number}// 此函数只能传入拥有length的类型function echoWidthArr &lt;T extends IWidthLength&gt;(arg: T): T { console.log(arg.length) return arg}const arr = echoWidthArr([1, 2, 3])const str = echoWidthArr('123')// {} 本身会报错，但是只要给他添加length属性，就可以避免报错const obj = echoWidthArr({length: 0})// 报错const obj1 = echoWidthArr({})利用泛型来判断需要返回的类型12345678// 如果是空或者undefined则返回never 否则返回原先的类型type NonType&lt;T&gt; = T extends null | undefined ? never : Tlet demo1: NonType&lt;number&gt; = 1// 当类型为null或undefined时，则直接返回neverlet demo2: NonType&lt;null&gt; = null利用泛型实现类型校验1234type ValidateMap&lt;T&gt; = { // 首先判断是否为空类型，是则返回一个NonType, 否则在检查是否为undefined 如果是则也返回NonType, 否则利用NoneType返回原类型 [K in keyof T]?: null extends T[K] ? NonType&lt;T[K] | null | undefined&gt; : undefined extends T[K] ? NonType&lt;T[K] | null | undefined&gt; : NonType&lt;T[K]&gt;}声明文件许多原本没有Ts支持的库，在这个项目中都有人写好了声明文件https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types123declare var jQuery: (selector: string) =&gt; any;jQuery('#foo');","link":"/2022/02/08/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91ts%E6%B7%B1%E5%85%A5/"},{"title":"【前端】vue全局弹窗组件实现","text":"主要内容弹窗组件的设计和实现实现弹窗组件弹窗这类组件的特点是他们在当前vue实力之外独立存在，通常挂载于body; 他们是通过js动态创建的，不需要再任何组件中设声明以element为例子12345this.$message({ title: '性感前端在线炒粉', message: '提示信息', duration: 1000})实现先写一个tiptop.vue文件，使用fixed布局，z-index使它永远在最上层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class=\"box\" v-if=\"isShow\"&gt; &lt;h3&gt;{{title}}&lt;/h3&gt; &lt;p class=\"box-content\"&gt;{{message}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { props: { title: { type: String, default: \"\" }, message: { type: String, default: \"\" }, duration: { type: Number, default: 1000 } }, data() { return { isShow: false, timer: null }; }, methods: { show() { this.isShow = true; timer = setTimeout(this.hide, this.duration); }, hide() { this.isShow = false; timer &amp;&amp; clearTimeout(timer) this.remove(); // 这个方法后面直接挂载到实例上，这里不定义 } } };&lt;/script&gt;&lt;style&gt; .box { position: fixed; width: 100%; top: 16px; left: 0; text-align: center; pointer-events: none; z-index: 999; } .box-content { width: 200px; margin: 10px auto; font-size: 14px; border: blue 3px solid; padding: 8px 16px; background: #fff; border-radius: 3px; margin-bottom: 8px; }&lt;/style&gt;创建一个方法用来在外部调用这个组件1234567891011121314151617181920import vue from 'vue'import tiptop from './tiptop'function _tipTop (props) { const _vm = new vue({ render(h) { // 调用刚刚引入的组件，传入参数 return h(tiptop,{ props }) } // 执行挂载函数，但未设置挂载目标，表示只执行了初始化的工作 }).$mount() // 通过$el获取到真实的element并且挂载在body上 document.body.appendChild(vm.$el) // 获取组件实例，挂载remove方法 const comp = vm.$children[0] comp.remove = ()=&gt; { document.bodu.removeChild(vm.$el); vm.$destroy() }}","link":"/2020/09/07/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91vue%E5%85%A8%E5%B1%80%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0/"},{"title":"基础知识","text":"从输入URL到页面加载完成，发生了什么用户输入网址浏览器通过DNS把URL解析成IP和ip地址建立TCP链接，发送HTTP请求服务器接收请求，查库，读文件，拼接好返回的Http响应浏览器收到HTML,开始渲染解析html为dom解析css为css-treedom+ css生成render-tree加载script的js文件执行jsHttp协议状态码","link":"/2020/01/18/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"实现水平垂直居中","text":"css实现水平居中方法一12345div.parent { display: flex; justify-content: center; align-items: center;}方法二123456789101112131415161718192021222324252627282930313233div.parent { position: relative;}div.child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);}/* 或者 */div.child { width: 50px; height: 10px; position: absolute; top: 50%; left: 50%; margin-left: -25px; margin-top: -5px;}/* 或 */div.child { width: 50px; height: 10px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;}方法三12345678div.parent { display: grid;}div.child { justify-self: center; align-self: center;}方法四1234567891011121314151617div.parent { font-size: 0; text-align: center; &amp;::before { content: \"\"; display: inline-block; width: 0; height: 100%; vertical-align: middle; }}div.child { display: inline-block; vertical-align: middle;}html代码12345&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","link":"/2020/01/18/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"},{"title":"实现移动端适配","text":"一、原理使用js 根据html 的宽度动态调整font-size的大小具体实现实际上非常简单，三行代码搞定1234let htmlWidth = document.documentElement.clientWidth || document.body.clientWidthlet htmlDom = document.getElementsByTagName('html')[0] // 选中 html//20 iphone5se 320像素下 font-size 是 16px ，相差20倍 所以除20htmlDom.style.fontSize = htmlWidth/20 + 'px'窗口大小发生改变使用这个会发现当页面宽度发生改变的时候，页面并没有实时变化12345678910111213//监听 window.onresize事件//保证页面初始化时自动执行一次resetrem()function resetrem(){ let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth let htmlDom = document.getElementsByTagName('html')[0] // 选中 html //20 iphone5se 320像素下 font-size 是 16px ，相差20倍 所以除20 htmlDom.style.fontSize = htmlWidth/20 + 'px'}//窗口宽度发生改变再次执行window.onresize = ()=&gt;{ resetrem()}分辨率过高,或设备横屏现在你会发现，tm要是横屏或者是pc，你的样式又崩了所以需要加点限制123456789function resetrem(){ let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth let htmlDom = document.getElementsByTagName('html')[0] // 选中 html if(htmlWidh&gt;750){ htmlWidth = 750 + 'px' } //20 iphone5se 320像素下 font-size 是 16px ，相差20倍 所以除20 htmlDom.style.fontSize = htmlWidth/20 + 'px'}","link":"/2019/08/30/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"title":"JS ES6原生触摸事件的封装","text":"JS ES6原生触摸事件的封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * param 原生js方式实现判断用户的滑动方向 * 返回1 向上 * 返回2 向下 * 返回3 向左 * 返回4 向右 */class juedgeSlide { constructor() { this.startx = ''; this.starty = ''; } //获得角度 getAngle(angx, angy) { return Math.atan2(angy, angx) * 180 / Math.PI; }; //根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动 getDirection(startx, starty, endx, endy) { var angx = endx - startx; var angy = endy - starty; var result = 0; //如果滑动距离太短 if (Math.abs(angx) &lt; 2 &amp;&amp; Math.abs(angy) &lt; 2) { return result; } var angle = this.getAngle(angx, angy); if (angle &gt;= -135 &amp;&amp; angle &lt;= -45) { result = 1; } else if (angle &gt; 45 &amp;&amp; angle &lt; 135) { result = 2; } else if ((angle &gt;= 135 &amp;&amp; angle &lt;= 180) || (angle &gt;= -180 &amp;&amp; angle &lt; -135)) { result = 3; } else if (angle &gt;= -45 &amp;&amp; angle &lt;= 45) { result = 4; } return result; } // 初始化函数 init(callback) { var that = this; //手指接触屏幕 document.addEventListener(\"touchstart\", function (e) { that.startx = e.touches[0].pageX; that.starty = e.touches[0].pageY; }, false); document.addEventListener(\"touchmove\", function (e) { var endx, endy; endx = e.changedTouches[0].pageX; endy = e.changedTouches[0].pageY; var direction = that.getDirection(that.startx, that.starty, endx, endy); callback(direction, true); }, false); //手指离开屏幕 document.addEventListener(\"touchend\", function (e) { var endx, endy; endx = e.changedTouches[0].pageX; endy = e.changedTouches[0].pageY; var direction = that.getDirection(that.startx, that.starty, endx, endy); callback(direction, false); }, false); }}","link":"/2020/08/16/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"},{"title":"有趣的网站","text":"收集一些常用的工具windows10 office 离线激活HEU_KMS_Activator_v19.5.1视频下载urlgot(需翻墙/全局模式)直接将视频网址复制上去就可以了，几乎支持所有视频类的网站，只是支持度可能不同。1https: //www.urlgot.com/大像素1http: //www.bigpixel.cn/index.htmlPPT1https: //slidesge.com/theme/isometric-proposal云1https: //www.ianfisherart.com/展会1http: //www.eshow365.com/全历史1https: //www.allhistory.com/诡秘之主1https: //www.zceol.com.cn/werk/ZNDIONzUzNzY=.html背景素材1http: //bg-patterns.com/壁纸1https://wall.alphacoders.com字体转换","link":"/2019/08/30/%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/"},{"title":"【webpack】使用webpack4配置自己的react-cli","text":"简介公司用的是 JQuery + 原生js 来写的页面, 这就让我很头疼，最近学习了下 webpack ，于是将原来写的代码全部用 webpack 进行了一次打包和压缩，将我自己用 zrender 写的一个地图绘图工具管理页面用 react 重写了，并且用 webpack 打包。通过使用 webpack 终于脱离了 Jquery + 原生js 操作 dom 来开发的苦海。webpack 初始化安装新建一个文件夹 myReact-cli ;-myReact-cli-src -assets -components -app.js -index.html -index.js -webpack.config.js初始化node环境npm init –y安装webpacknpm install webpack webpack-cli –d安装各类loadercssnpm install –d style-loader css-loader postcss-loaderscssnpm install –d sass sass-loaderfile-loadernpm install –d file-loader安装react依赖npm install –d react react-dom配置基本的webpack安装所需要的 webpack pluginsnpm install –save-dev html-webpack-plugin //自动生成html入口文件npm install –save-dev clean-webpack-plugin //devServer清理dist文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const path = require('path');const fs = require('fs');const HtmlWebpackPlugin = require('html-webpack-plugin')const { CleanWebpackPlugin} = require('clean-webpack-plugin') //自动删除dist中的文件const webpack = require('webpack')const config = { mode: 'development', entry: { index: `${__dirname}/src/index.js` //打包入口 }, output: { path: `${__dirname}/dist` , //生成在项目根目录的dist文件夹中 filename: '[name].js' }, resolve: { alias: { '@': `${__dirname}/src` , //import 引入的别名 } }, module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: [ 'babel-loader' ] }, { test: /\\.scss$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader', options: { importLoaders: 2, modules: true } }, { loader: 'sass-loader' }, { loader: 'postcss-loader' } ] }, { test: /\\.css$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader', options: { importLoaders: 2, modules: true } }, { loader: 'postcss-loader' } ] }, { test: /\\.less$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader', options: { importLoaders: 2, modules: true } }, { loader: 'less-loader' }, { loader: 'postcss-loader' } ] }, { test: /\\.(jpg|jpeg|png|gif)$/, use: [{ loader: 'file-loader', options: { name(file) { if (process.env.NODE_ENV === 'development') { return '[path][name].[ext]'; } return '[hash].[ext]'; }, publicPath: 'assets/images', //文件的访问地址 outputPath: 'assets/images' //文件的输出文件夹 } }] } ] }, plugins: [ new HtmlWebpackPlugin({ template: `${__dirname}/src/index.html` //自动生成index.html模板地址会自动把打包后的index.js引入 }), new CleanWebpackPlugin(), new webpack.HotModuleReplacementPlugin() ], devServer: { contentBase: `${__dirname}/dist` , open: false, port: 8080, hot: true, hotOnly: true }, optimization: { minimize: true //打开压缩 }, devtool: 'cheap-module-eval-source-map' //生成列文件路径，給各个模块也生成，使用eval方式进行编译打包，生成source-map文件。}module.exports = configbabel 配置安装所需要的babel依赖npm install–save -dev babel-loadernpm install–save -dev @babel/corenpm install–save -dev @babel/preset-envnpm install–save -dev @babel/preset-reactnpm install–save -dev @babel/polyfill在项目根目录下新建 .babelrc 文件配置如下12345678910111213141516171819202122{ \"plugins\": [], \"presets\": [ [ \"@babel/preset-env\", { //配置按需引用 \"useBuiltIns\": \"usage\", //配置兼容范围 \"targets\": \"&gt; 0.25%, not dead\", //https://www.babeljs.cn/docs/babel-preset-env corejs可以看看官网的解释 \"corejs\": { \"version\": 3, \"proposals\": true } } ], [ \"@babel/preset-react\" //解析react语法 ] ]}在项目下新建 .gitignore 文件12node_modules / dist /","link":"/2020/03/04/%E4%BD%BF%E7%94%A8webpack4%E9%85%8D%E7%BD%AEreact-cli/"},{"title":"【成长】如何突破平台期","text":"【成长】如何突破平台期复杂项目业务的复杂度业务的复杂性交互的复杂性数据结构和状态的复杂性多项目的打包性能优化第三方模块的二次开发流程的复杂度git flowlint 工具单元测试commit 信息PR reviewCI/CD","link":"/2022/01/16/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4%E5%B9%B3%E5%8F%B0%E6%9C%9F/"},{"title":"【linux】【树莓派】树莓派初探","text":"树莓派购买这次买的树莓派4B 32 + 4 的配置价格：495配件：外壳、风扇、网线、Hdmi(microHDMI—HDMI)配置：4 + 32这个价格比阿里云的轻量级服务器500+一年可划算多了，学生（144/年），可惜我已经不是学生了树莓派系统镜像烧录资源下载镜像烧录工具Raspberry Pi Imagerlinux镜像ubuntu-20.04.1-preinstalled-server-arm64+raspi.img想下其他镜像可以去这看看源网站注意备份SD卡的数据！！！打开Raspberry Pi Imager在第一个选项中选中Erase选项第二个选项选中自己插入的SD卡点击WRITE将SD卡格式化再此点击第一个选项，这次选择Use custom,之后选择刚刚下载的镜像、再次点击write按钮开始烧录系统==之后就是等待进度条跑完==开启树莓派【注意】先不要将风扇接上，只接网线就行、否则可能无法正常开机！！！使用xhell连接树莓派到路由器管理页面去看有没有新设备加进来、新加入设备的ip就是xhell连接的ip默认的用户名、密码都是: ubuntu首次登录成功后，会让你修改默认的密码，需要先输入默认密码，再输入两次新密码。修改软件源执行下面的代码来修改源文件sudo vim /etc/apt/sources.list这里使用清华大学开源镜像源12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse修改完成后执行sudo apt updatesudo apt upgradesudo apt install ubuntu-desktopsudo apt install xrdp执行到这里 需要重启下sudo reboot修改root密码sudo passwd root让root可以登录vim vim /usr/share/lightdm.conf.d/50-ubuntu.conf12greeter-show-maual-logi=trueallow-guest=false修改好后再重启一次sudo reboot使用windows远程连接ubuntuwin + r mstsc输入树莓派ip地址，然后输入root和对应的密码即可登录图形化界面使用中文【注意】你所看到的可能是英文的，只需要按位置找到对应的按钮、选项就行了右上角设置选择区域和语言，如果没有则选择“管理已安装的语言”之后选择“添加或删除语言”找到中文点击应用、然后重启生效解决root登出后密码正确的情况下无法登录的问题使用xshell 连接,修改三个文件sudo -ivim /etc/pam.d/gdm-autologin注释掉auth required pam_succeed_if.so user != root quiet_success一行（行前加 #）vim /etc/pam.d/gdm-password注释掉auth required pam_succeed_if.so user != root quiet_success一行（行前加 #）sudo vim /root/.profile注释掉原来的mesg,修改成图上的样子reboot再次使用windows远程到ubuntu的时候图形化界面就可以正常登录了","link":"/2020/08/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E6%8E%A2/"},{"title":"【花活】犀皮漆器的一般制作步骤","text":"犀皮漆器一般步骤准备工作制作简易的荫箱 温度20摄氏度，湿度75%笔刷清洗松节油-&gt;保鲜膜松节油浸泡-&gt;揭开保鲜膜用植物油清洗-&gt;水冲洗制作步骤，注意事项打磨使用400目砂纸打磨器物表面粗糙使得大漆更易附着上生漆漆要薄，均匀，太厚会起皱，太会露底（阴干8小时）后再用400目的砂纸进行打磨，如果露底了，就需要补漆打埝注意：打埝用的漆的颜色任选。加蛋清（蛋清1：3大漆）的比例来调制埝漆打埝的工具有很多种，牙签、丝瓜瓤、钢丝球等类似特性的物体都可以使用埝的疏密程度和高度都可以自己控制埝干燥需要15 - 20天刚打的埝先在正常环境下进行放置，防止埝塌陷调埝漆需要耐心，有拔丝的效果即可开始打埝髤色漆注意：这个步骤一定要等到埝完全干透才能开始将用到的色漆使用10%左右的稀释剂稀释埝干后，髤黑色漆,黑色漆干后髤红色漆、红色漆用手去触碰有点粘手，但不会把漆黏下即可贴金，贴金等干燥后，上透明漆，漆尽量涂的薄一些。这个步骤可以重复多次，一般15 - 60层不等。打磨抛光按顺序耐心打磨，注意不要磨穿了。效果图","link":"/2020/11/21/%E7%8A%80%E7%9A%AE%E6%BC%86%E5%99%A8%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%B6%E4%BD%9C%E6%AD%A5%E9%AA%A4/"},{"title":"【Markdown】Markdown 语法基础","text":"wordpress创建的博客维护起来很不方便，而且他的编辑器用起来也非常蛋疼，还需要一台服务器来部署，综合各种原因，还是将博客迁移到hexo + githubpage。一、标题语法# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题标题语法效果这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体语法**加粗文字** *倾斜文字*` ***倾斜加粗*** ~~删除线文字~~字体语法示例这是加粗的文字这是倾斜的文字倾斜加粗这是删除线三、引用&gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;这是引用的内容引用效果这是引用的内容这是引用的内容这是引用的内容这是引用的内容四、分割线三个或三个以上--- ***效果五、图片!['图片alt']('图片地址',''图片title'') []内图片底下的标题，title可加可不加示例六、超链接[链接名](超链接地址 &quot;超链接title&quot;) title 可加可不加示例：[bilibili](https://www.bilibili.com) 只能在本页面打开链接 &lt;a href=&quot;bilibili&quot; target=&quot;_blank&quot;&gt;bilibili&lt;/a&gt; 在新页面打开链接效果：在本页面打开的: bilibili新页面：bilibili七、列表无序列表使用 - + * 其中一个都可以 - 列表内容 * 列表内容 + 列表内容效果列表内容列表内容列表内容有序列表列表内容列表内容列表内容数字加点，点后面接空格效果列表内容列表内容列表内容列表嵌套回车敲3个空格大列表小列表迷你列表八、表格1234th|th|th|--|:--:|--:td|td|tdtd|td|td示例12345姓名|年龄|身高:--|:--:|:--张三|18|180cm李四|19|159cm王五|17|179cm效果姓名年龄身高张三18180cm李四19159cm王五17179cm九、代码块单行代码`代码内容`效果const a = '321312'代码块(```) (async ()=&gt;{ var a = '' await setTimeout(()=&gt;{ a = '这是一句3秒前说的话' },3000) console.log(a) })() (```)效果1234567 (async ()=&gt;{ var a = '' await setTimeout(()=&gt;{ a = '这是一句3秒前说的话' },3000) console.log(a)})()十、流程图12345678st=&gt;start: 开始op=&gt;operation: my Optioncond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;效果 似乎不支持1234567st=&gt;start: 开始op=&gt;operation: my Optioncond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op效果截图","link":"/2019/08/29/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"title":"【hexo】hexo 搭建博客 托管在github","text":"一、github 开启展示页面打开你的GitHub点击new repository输入你的github账户名(这个库的名字必须跟你的github用户名一致)进入这个仓库的设置界面,将Template repository选项选中滚动到页面底部 有一栏github pages的内容,点击Choose a theme去选择一个主题，完成后在浏览器输入 XXX.github.io就能看到你现在这个仓库所托管的页面了二、环境的安装你需要安装 git工具,node运行环境,来支持HEXO的使用、运行，安装方式很简单。一直点就行。git会介绍初始化的一些命令，git,node安装相对简单，就不多介绍了。git 官网https://git-scm.com/downloadsnode 官网https://nodejs.org/zh-cn/hexo官方文档https://hexo.io/zh-cn/docs/index.htmlgit初始化新装的git，以下两行命令来初始化你的git,以后所有的github仓库都会默认使用这账号来创建12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;关联github仓库与本地git第一步，需要创建SSH key。到电脑C:\\Users\\用户.ssh 下去看看有没有这两个文件id_rsaid_rsa.pub如果有请跳过这个步骤，如果没有请执行12$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;将生成的id_rsa.pub里面的内容复制出来，到你的github上选择个人设置选择SSH and GPG keys点击new SSH key将你复制的id_rsa.pub的内容复制进去就好了，title可以随便取，key要是id_rsa_pub中的内容三、安装HEXO打开CMD命令行工具或者右键选择git bash here执行以下命令npm install -g hexo-cliHEXO 初始化到你准备好存放博客的文件夹中 右键选择 git bash here 执行以下命令hexo init //初始化hexo初始化完后的目录如下12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themesnpm install //安装hexo 需要的组件npm install hexo-deployer-git //文章发布相关hexo g //创建静态文件hexo s //启动本地预览hexo s 执行成功后，出现以下提示，就可以在http://localhost:4000预览你的博客内容，CTRL + C 停止预览12INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.将HEXO push到github上打开_config.yml文件修改以下配置，保存。123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master在这个目录下，右键git bash here执行以下命令就能将本地的博客内容上传到github上。hexo clean //清除之前hexo g 创建的静态文件hexo new post ‘HELLO HEXO !!!’ //创建新文章hexo g //创建静态文件hexo d //发布文章3. ##### 修改新建文章的模板修改hexo根目录下/scaffolds/post.md文件1234567891011121314151617---title: typora-vue-theme主题介绍date: author: 谢子乾img: /source/images/xxx.jpgtop: true //是否在首页推荐显示cover: true //是否加入首页的轮播图coverImg: /images/1.jpg //轮播图使用的图片password: toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdown //文章分类tags: - Typora - Markdown---四、主题的选择因为我使用了hexo-theme-matery主题，所以将围绕本主题展开介绍，这个主题有官方的中文文档。在这里我就不过多介绍了。更多配置请看本站Hexo的抖机灵用法一文。hexo 还有许多主题有能力的朋友可以使用其他自己喜欢的主题。站点运行时间统计在主题目录下的layout/_partial/footer.ejs添加以下内容添加到footer标签内部1&lt;span id=\"sitetime\"&gt;&lt;/span&gt;下面这段放在footer标签外12345678910111213141516171819202122232425262728&lt;script&gt; function setTime(){ window.setTimeout(\"setTime()\", 1000) var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(2019, 08, 29, 15, 04, 00); var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); document.getElementById(\"sitetime\").innerHTML = \"本站已运行 \" +diffYears+\" 年 \"+diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } setTime();&lt;/script&gt;添加站点进入人数统计到主题的_config.yml文件中，修改为 true123456# busuanzi(http://busuanzi.ibruce.info/) website statistics# 不蒜子(http://busuanzi.ibruce.info/) 网站统计busuanziStatistics: enable: true totalTraffic: true # 总访问量 totalNumberOfvisitors: true # 总人次同样在 footer.ejs这个文件的script标签中添加以下代码12345678910111213141516function setbusuanzi(){ var interval = 50; var int = setInterval(fixCount, interval); var pvcountOffset = 2000; var uvcountOffset = 1000000; function fixCount(){ if(document.getElementById('busuanzi_container_site_pv').style.display != 'none'){ $(\"#busuanzi_container_site_pv\").html(parseInt($('#busuanzi_value_site_pv').html() + pvcountOffset )) clearInterval(int) } if($(\"busuanzi_container_site_uv\").css(\"display\") !=\"none\"){ $('#busuanzi_value_site_uv').html(parseInt($(\"#busuanzi_value_site_uv\").html()) + uvcountOffset) clearInterval(int) } } }五、borwsersync 实现实时更新修改的样式文件刚刚搭建好的hexo博客，需要根据自己的需求修改很多样式，但是修改样式的过程中发现hexo并不能够像webpack一样实时刷新。于是，经过一番搜索 了解了 hexo-browsersync使用方式很简单npm install hexo-browsersync –save安装完成后 再次输入 hexo s 出现以下提示就说明成功了12345678910hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ----------------------------------六、看板娘hexo 本身就有对看板娘支持的模块npm install –save hexo-helper-live2d安装完之后在_config.yml进行以下配置12345678910111213141516171819202122232425# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: left width: 150 height: 300 mobile: show: true # 手机中是否展示然后就可以看到效果了,可能跟我的效果有些差距，请继续下面的步骤这时的看板娘还不会说话还需要几步操作，实现看板娘的人物切换，换装，说话，游戏等看板娘进阶首先下载或克隆https://github.com/stevenjoezhang/live2d-widget并且将它解压到你hexo的主题的source目录下进入这个文件夹live2d-widget-master打开autoload.js文件将1const live2d_path = \"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/\";修改成123const live2d_path = \"/live2d-widget/\";//这个path是要看具体的文件夹名字的有时候会多出 -master 则修改为下面这样const live2d_path = \"/live2d-widget-master/\";进入到博客的layout/layout.ejs 如果你的主题是next则是/themes/next/layout/_layout.swing新增以下内容123&lt;script src=\"/live2d-widget/autoload.js\"&gt;&lt;/script&gt;&lt;!-- 这里要注意，你下载下来的文件夹名成可能是 //live2d-widget-master/ 需要修改成下面这样--&gt;&lt;script src=\"/live2d-widget-master/autoload.js\"&gt;&lt;/script&gt;看板娘个性化想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js、 waifu-tips.json 、waifu.css文件。八、hexo d命令会重置域名使用hexo d命令会重置你绑定的域名，只需要在hexo的source目录下新建一个CNAME文件内容是你绑定的域名，以后再发布绑定的域名就不会被重置了！九、页面级别的音乐播放器hexo有音乐播放器，但是只能在一个页面播放音乐，想要实现在每篇文章中都用不同的背景音乐其实挺麻烦的。下介绍如何在文章中插入自己想要的音乐npm install –save hexo-tag-aplayer直接在文章想要插入音乐的地方加上这段代码就行了12345678910111213{% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %}//参数说明标签参数title : 曲目标题author: 曲目作者url: 音乐文件 URL 地址picture_url: (可选) 音乐对应的图片地址narrow: （可选）播放器袖珍风格autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能width:xxx: (可选) 播放器宽度 (默认: 100%)lrc:xxx: （可选）歌词文件 URL 地址如果你开启了hexo的文章资源文件夹功能时，可以将图片音乐文件，歌词放入对应的文件中，然后直接引用1{% aplayer \"NEMO\" \"Jeff Williams\" \"http://120.78.145.101:32450/Nemo.flac\" \"picture.jpg\" \"lrc:caffeine.txt\" %}效果var ap=new APlayer({element:document.getElementById(\"aplayer-AmPFcmyc\"),narrow:!1,autoplay:!1,showlrc:!1,music:{title:\"NEMO\",author:\"NightWish\",url:\"http://120.78.145.101:32450/Nemo.flac\",pic:\"http://wapsh.top/wp-content/uploads/2019/08/5.jpg\",lrc:\"\"}});window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)扩展本文参考的文章hexo-theme-matery主题官方文档https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md韦阳的博客 超详细Hexo+Github博客搭建小白教程一文https://godweiyang.com/2018/04/13/hexo-blog/live2d-widget官方文档https://github.com/stevenjoezhang/live2d-widget看板娘美化https://www.jianshu.com/p/89440678ee3c","link":"/2019/08/31/hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%20github%20%E6%89%98%E7%AE%A1%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"},{"title":"【webpack】 webpack使用记录","text":"webpackwebpack基本用法记录https://segmentfault.com/a/1190000021824673webpack安装npm init –ynpm install -d webpack webpack-cli全局安装webpack太呆了使用ES6语法, 并且做兼容babel官网☞安装依赖npm install –save-dev babel-loader @babel/corenpm install –save-dev @babel/preset-envnpm install –save-dev @babel/plugin-transform-runtimenpm install –save @babel/runtimenpm install –save-dev @babel/runtime-corejs2npm install –save-dev @babel/polyfillbabel配置如果是业务需求的代码在入口文件中引入 @babel/polyfill如果是通用组件使用 runtime 形式则不加，如果加了，请删除。1import '@babel/polyfill'如果在 webpack.config.js 中配置12345678910111213141516171819202122232425262728293031323334//presets 和 plugins二选一，共存优先使用presets的设置const presets = [ [\"@babel/preset-env\", { useBuiltIns: 'usage', targets: { chrome: '67' } }]];const plugins = [ [\"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false, \"version\": \"7.0.0-beta.0\" }]]module.exports = { module: { rules: [{ rules: [{ test: /\\.js$/, exculde: /node_modules/, loader: 'babel-loader', options: { presets, //业务开发使用 plugins //通用组件开发使用 } }] }] }}如果在 .babelrc 文件中配置1234567891011121314151617181920212223{ \"plugins\": [[\"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 2, \"helpers\": true, \"regenerator\": true, \"useESModules\": false, \"version\": \"7.0.0-beta.0\" }]] \"options\": { \"presets\": [[\"@babel/preset-env\", { \"useBuiltIns\": \"usage\", //只有使用了对应的语法才会引入polyfill兼容 \"targets\": { \"chrome\": \"67\" //兼容浏览器的版本 /*示例环境：chrome，opera，edge，firefox，safari，即ios，android，node，electron。 旁注，如果未指定目标，则默认情况下@ babel / preset-env将转换所有 ECMAScript 2015+代码。 */ }, /* 或者这样写，只兼容市场份额大于 0.25%的浏览器 */ \"targets\": \"&gt; 0.25%, not dead\" }]], }}使用 tree shaking 让 webpack 只加载 import 之后使用的代码，删除 import 未使用的代码。webpack.config.js123456module.exports = { mode: 'development', optimization: { usedExports: true, },}package.json12345{ \"name\": \"your-project\", \"sideEffects\": false //如果所有代码都不包含 side effect，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export。}如果有些在导入时会在全局环境中挂载一些变量方法 webpack 还没有聪明到能自己识别这种特殊情况所以我们需要告诉他。12345678{ \"name\": \"your-project\", \"sideEffects\": [ \"./src/some-side-effectful-file.js\", \"*.css\", \"*.scss\" ]}这时候回到webpack.config.js中123module.export = { mode: 'production'}想要使用 tree shaking 必须注意以下……使用 ES2015 模块语法（即 import 和 export ）。确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为）。在项目 package.json 文件中，添加一个 “ sideEffects “ 属性。通过将 mode 选项设置为 production ，启用 minification (代码压缩) 和 tree shaking 。你可以将应用程序想象成一棵树。绿色表示实际用到的 source code (源码) 和 library (库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。区分 development 和 production 的 webpack.config.js分3个模式将配置分为三份，直接分的话会有很多重复的部分，所以需要把3个模式下都需要的公共配置抽取出来，导出时使用 webpack-merge 合成对应的配置文件。在项目根目录下新建一个 build 文件夹，用于存放配置文件修改 package.json123456789{ \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\", \"build\": \"webpack --config ./build/webpack.prod.js\", \"product\": \"webpack --config ./build/webpack.prod.js\", \"dev-build\": \"webpack --config ./build/webpack.dev.js\" },}分离公共部分配置 webpack.comm.js需要把dev和prod模式下都需要用到的配置抽取出来，放到webpack.comm.js中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const HtmlWebPackPlugin = require('html-webpack-plugin')const { CleanWebpackPlugin} = require('clean-webpack-plugin')const indexFile = `${__dirname}/example` module.exports = { entry: { main: `${indexFile}/hmr&amp;loader/index.js` , }, output: { path: __dirname + '/dist', filename: 'main.js', }, module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' // options: { // presets: [[\"@babel/preset-env\", { // useBuiltIns: 'usage', // targets: { // chrome: '67' // } // }]], // } }, { test: /\\.(png|jpg|gif)$/, use: { loader: 'file-loader', options: { name: '[hash].[ext]', } } }, { test: /\\.scss$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader', options: { importLoaders: 2, modules: true } }, { loader: 'sass-loader', options: { } }, { loader: 'postcss-loader' } ] }, { test: /\\.css$/, use: [{ loader: 'style-loader' }, { loader: 'css-loader', }, { loader: 'postcss-loader' } ] } ] }, plugins: [ new HtmlWebPackPlugin(), new CleanWebpackPlugin(), ], devServer: { contentBase: \"/dist\", open: false, port: 8080, hot: true, hotOnly: true }}分离 dev 和 prod 模式下的独有配置并用 webpack-merge 导出dev 模式1234567891011121314151617const commConfig = require('./webpack.comm.js')const webpack = require('webpack')const merge = require('webpack-merge')const devConfig = { mode: 'development', optimization: { //tree shaking usedExports: true }, plugins: [ new webpack.HotModuleReplacementPlugin() ], devtool: \"cheap-module-source-map\"}module.exports = merge(commConfig, devConfig)prod 模式12345678const commConfig = require('./webpack.comm.js')const merge = require('webpack-merge')const prodConfig = { mode: 'production', devtool: \"cheap-module-source-map\"}module.exports = merge(commConfig, prodConfig)","link":"/2020/02/28/webpack%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"},{"title":"【vue】无缝token刷新","text":"利用axios interceptors实现无感续期token后台有两个token, 一个是正常api用token, 一个是用来续期api token的refreshToken，正常的流程一般是 api token过期，使用refreshToken来续期，当refreshToken都过期后，就算用户登录超时了，用户每使用一次 api token, 后台都会给refreshToken 重置过期时间。最长不超过24小时。新建axios实例，设置基础配置通过整个项目都是通过这个axios实例来调用接口的12345const instance = axios.create({ timeout: 1000 * 12 })let lastConfig = null// 设置请求头，默认为 jsoninstance.defaults.headers.post['Content-Type'] = 'application/json;charset=UTF-8'通过请求拦截器注入token通过axios 请求拦截器在请求之前将token加在请求头中，并且在这里备份下用户的请求配置（包括请求头，数据），这个接口请求失败后通过这个config继续请求12345678910111213// axios 请求拦截器 token 注入instance.interceptors.request.use( config =&gt; { const token = getToken() token &amp;&amp; (config.headers.Authorization = token) // 缓存访问的配置 decoup是用来解耦的 lastConfig = decoup(config) return config }, error =&gt; { return Promise.error(error) })通过返回拦截器处理请求失败的情况通过后端返回的状态，判断接口请求的情况，如果接口返回token过期，就调用refreshToken刷新token，在刷新token的接口在请求时如果还有其他接口被调用了，利用promise reslove的状态，将此阶段调用的接口状态全部暂存，当refreshToken返回了新token就使用新token继续调用之前暂存的请求，如果refreshToken返回refreshToken过期则直接要求用户重新登录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// axois 返回拦截器 错instance.interceptors.response.use( // 请求成功不做处理 async (response) =&gt; { if (resHandle[response.data.code]) { // 这里时防止多次弹出同一个警告窗口 if (isFailing) return isFailing = true resHandle[response.data.code]() } // token过期，进入刷新token流程 if (response.data.code === ruleStatus.expired) { const config = response.config // 判断是否在获取新token if (!isRefreshing) { isRefreshing = true // 调用刷新token的接口 return refreshToken().then(success =&gt; { const code = success.data.code // refreshToken过期 if (code === ruleStatus.refreshTokenInvalid) { MessageBox({ message: i18n.t('http.refreshTokenInvalid'), duration: 2000, type: 'warning' }) // 跳转到登录页面 goToLogin() return } // 刷新token const data = success.data.data // 刷新,刷新token的token local.refreshToken = data.refreshToken // 刷新正常的token local.token = formatToken(data.token_type, data.token) // 调用成功的回调 const token = local.token config.headers.Authorization = token requests.forEach(cb =&gt; cb(token)) requests = [] return instance(config) }).catch(err =&gt; { console.error('refreshtoken error =&gt;', err) goToLogin() }).finally(() =&gt; { isRefreshing = false }) } else { return new Promise((resolve) =&gt; { requests.push((token) =&gt; { let temp = null temp = lastConfig temp.headers.Authorization = token resolve(instance(temp)) }) }) } } isFailing = true return response }, (error) =&gt; { if (error.response.status) { const status = error.response.status if (resHandle[status]) { // 按照不同的错误码调用不同的方法 resHandle[status](error) } else { Message({ message: i18n.t('response.error') + status, duration: 3000, type: 'warning' }) } } })完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195import axios from 'axios'import router from '../router'import { Message, MessageBox } from 'element-ui'import { decoup, formatToken, debounce } from '@/common/js/util'import local from '../common/js/localTypes.js'import base from './base'import i18n from '@/common/i18n/i18n.js'import httpLang from './i18n.config.js'i18n.addNewLang(httpLang)let isRefreshing = falselet requests = []let isFailing = falseconst ruleStatus = { noRules: '200200', // 无权限 expired: '200300', // 过期 invalid: '200001', // 无效token refreshTokenInvalid: '200400', // 刷新token的token过期 illegalrefresh: '200402'}const getToken = () =&gt; { return local.token}// console.log(getToken())const goToLogin = () =&gt; { // 返回登录页面 router.replace({ path: '/login' }) window.location.replace('/#/login')}const refreshToken = async () =&gt; { return axios({ url: base.loginUrl + '/oauth/refresh', headers: { Authorization: base.loginAuth, 'Content-Type': 'application/json' }, method: 'POST', params: { refreshToken: local.refreshToken } })}// 错误情况处理方法const resHandle = { // 防止多次调用刷新token的接口 10s内只能触发一次 401: debounce((error) =&gt; { MessageBox({ message: i18n.t('http.401') + error.response.status, duration: 2000, type: 'warning' }) goToLogin() }, 1000), 403: debounce((error) =&gt; { Message({ message: i18n.t('http.403') + error.response.status, duration: 2000, type: 'warning' }) }, 1000), 404: debounce((error) =&gt; { Message({ message: i18n.t('http.404') + error.response.status, duration: 2000, type: 'warning' }) }, 1000), 500: debounce((error) =&gt; { Message({ message: i18n.t('http.500') + error.response.status, duration: 2000, type: 'warning' }) }, 1000), 503 (error) { Message({ message: i18n.t('http.503') + error.response.status, duration: 2000, type: 'warning' }) }, [ruleStatus.illegalrefresh]: debounce(() =&gt; { MessageBox({ message: i18n.t('http.illegalrefresh'), duration: 2000, type: 'warning' }) goToLogin() }, 1000), [ruleStatus.invalid]: debounce(() =&gt; { MessageBox({ message: i18n.t('http.invalid'), duration: 3000, type: 'warning' }) goToLogin() }, 1000)}// 设置超时时间const instance = axios.create({ timeout: 1000 * 12 })let lastConfig = null// 设置请求头，默认为 jsoninstance.defaults.headers.post['Content-Type'] = 'application/json;charset=UTF-8'// axios 请求拦截器 token 注入instance.interceptors.request.use( config =&gt; { const token = getToken() token &amp;&amp; (config.headers.Authorization = token) // 缓存访问的配置 decoup是用来解耦的 lastConfig = decoup(config) return config }, error =&gt; { return Promise.error(error) })// axois 返回拦截器 错instance.interceptors.response.use( // 请求成功不做处理 async (response) =&gt; { if (resHandle[response.data.code]) { if (isFailing) return isFailing = true resHandle[response.data.code]() } if (response.data.code === ruleStatus.expired) { const config = response.config if (!isRefreshing) { isRefreshing = true return refreshToken().then(success =&gt; { const code = success.data.code if (code === ruleStatus.refreshTokenInvalid) { MessageBox({ message: i18n.t('http.refreshTokenInvalid'), duration: 2000, type: 'warning' }) goToLogin() return } // 刷新token const data = success.data.data // 刷新,刷新token的token local.refreshToken = data.refreshToken // setLocalStorage(localTypes.refreshToken, data.refreshToken) // 刷新正常的token local.token = formatToken(data.token_type, data.token) // setLocalStorage(localTypes.token, formatToken(data.token_type, data.token)) // 调用成功的回调 // const token = getLocalStorage(localTypes.token) const token = local.token config.headers.Authorization = token requests.forEach(cb =&gt; cb(token)) requests = [] return instance(config) }).catch(err =&gt; { console.error('refreshtoken error =&gt;', err) goToLogin() }).finally(() =&gt; { isRefreshing = false }) } else { return new Promise((resolve) =&gt; { requests.push((token) =&gt; { let temp = null temp = lastConfig temp.headers.Authorization = token resolve(instance(temp)) }) }) } } isFailing = true return response }, (error) =&gt; { if (error.response.status) { const status = error.response.status if (resHandle[status]) { resHandle[status](error) // 按照不同的错误码调用不同的方法 } else { Message({ message: i18n.t('response.error') + status, duration: 3000, type: 'warning' }) } return error } })export default instance","link":"/2020/12/28/%E3%80%90vue%E3%80%91%E6%97%A0%E7%BC%9Dtoken%E5%88%B7%E6%96%B0/"},{"title":"【前端】Vue组件通信","text":"props与$emit最常用的组合，props适合用作父组件传值给子组件，$emit经常用于基础组件封装的时间派发和数据传递（子组件向父组件传值）props在子组件中为只读属性，如果强行赋值修改，Vue会在控制台打印警告$emit 派发事件只有父节点才能监听到，如果跨层级，需要一级一级的使用$emit派发贴个基本使用、props向下传递同样有这个问题父组件12345678910111213141516171819Vue.component('parent', { template:` &lt;div&gt; &lt;p&gt;this is parent component!&lt;/p&gt; &lt;child :message=\"message\" @getChildData=\"getChildData\"&gt;&lt;/child&gt; &lt;/div&gt; `, data() { return { message: 'hello' } }, methods:{ // 执行子组件触发的事件 getChildData(val) { console.log(val); } }});子组件12345678910111213141516171819202122232425262728293031323334353637383940414243// 子组件Vue.component('child', { template:` &lt;div&gt; &lt;input type=\"text\" v-model=\"myMessage\" @input=\"passData(myMessage)\"&gt; &lt;/div&gt; `, /** * 得到父组件传递过来的数据 * 这里的定义最好是写成数据校验的形式，免得得到的数据是我们意料之外的 * * props: { * message: { * type: String, * default: '' * } * } * */ props:['message'], data() { return { // 这里是必要的，因为你不能直接修改 props 的值 myMessage: this.message } }, methods:{ passData(val) { // 数据状态变化时触发父组件中的事件 this.$emit('getChildData', val); } }}); var app=new Vue({ el: '#app', template: ` &lt;div&gt; &lt;parent /&gt; &lt;/div&gt; `});父组件通过props传递给子组件message，并且监听了子组件的getChildData事件，获取了子组件传递的val并打印子组件通过props获取到了父组件传递的值，并且使用$emit将myMessage传递给了父组件$attrs 和 $listenersVue 2.4 新增的两个属性，不关注官方文档的话，应该用的不是那么多，这两个属性对于上面提到的只能传递一级的问题有一定的效果，再也不用一个事件层层$emit，一个数据代代props了。简单来说 $attrs 就是跨层级版的 props, $listeners就是跨层级的$emit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 组件AVue.component('A', { template: ` &lt;div&gt; &lt;p&gt;this is parent component!&lt;/p&gt; &lt;B :messagec=\"messagec\" :message=\"message\" v-on:getCData=\"getCData\" v-on:getChildData=\"getChildData(message)\"&gt;&lt;/B&gt; &lt;/div&gt; `, data() { return { message: 'hello', messagec: 'hello c' //传递给c组件的数据 } }, methods: { // 执行B子组件触发的事件 getChildData(val) { console.log(`这是来自B组件的数据：${val}`); }, // 执行C子组件触发的事件 getCData(val) { console.log(`这是来自C组件的数据：${val}`); } }});// 组件BVue.component('B', { template: ` &lt;div&gt; &lt;input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\"&gt; &lt;!-- C组件中能直接触发 getCData 的原因在于：B组件调用 C组件时，使用 v-on 绑定了 $listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定 $attrs 属性，C组件可以直接获取到 A组件中传递下来的 props（除了 B组件中 props声明的） --&gt; &lt;C v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/C&gt; &lt;/div&gt; `, /** * 得到父组件传递过来的数据 * 这里的定义最好是写成数据校验的形式，免得得到的数据是我们意料之外的 * * props: { * message: { * type: String, * default: '' * } * } * */ props: ['message'], data(){ return { mymessage: this.message } }, methods: { passData(val){ //触发父组件中的事件 this.$emit('getChildData', val) } }});// 组件CVue.component('C', { template: ` &lt;div&gt; &lt;input type=\"text\" v-model=\"$attrs.messagec\" @input=\"passCData($attrs.messagec)\"&gt; &lt;/div&gt; `, methods: { passCData(val) { // 触发父组件A中的事件 this.$emit('getCData',val) } }}); var app=new Vue({ el:'#app', template: ` &lt;div&gt; &lt;A /&gt; &lt;/div&gt; `});组件A 监听 组件B的 getChildData 事件，监听组件C的getCData事件,向B传递了props message,还想向C传递messagec 于是先将messagec通过props的形式传递给组件B组件B 向A派发了getChildData事件，利用props只接收了message这个值,并没有接收messagec！！这点很重要，如果A组件的messagec属性需要向C组件传递，一定不能用props去接收，这样messagec才能挂载到组件B的$attr上,之后利用v-bind将$attr传递给C组件，并通过在C组件上监听$listener将A传递过来的非原生事件监听方法绑定到C上用来监听C组件的同类事件。用$emit props实现相同的功能1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('B', { template: ` &lt;div&gt; &lt;input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\"&gt; &lt;!-- C组件中能直接触发 getCData 的原因在于：B组件调用 C组件时，使用 v-on 绑定了 $listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定 $attrs 属性，C组件可以直接获取到 A组件中传递下来的 props（除了 B组件中 props声明的） --&gt; &lt;C v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/C&gt; 以上写法等效于 &lt;C :messagec=\"$attrs.messagec\" @getCData=\"$listeners.getCData\"&gt;&lt;/C&gt; &lt;/div&gt; `, props: ['message'], data(){ return { mymessage: this.message } }, methods: { passData(val){ //触发父组件中的事件 this.$emit('getChildData', val) } }});Vue.component('C', { template: ` &lt;div&gt; &lt;input type=\"text\" v-model=\"messagec\" @input=\"passCData($attrs.messagec)\"&gt; &lt;/div&gt; `, methods: { props: { messagec:'' }, passCData(val) { // 触发父组件A中的事件 this.$emit('getCData',val) } }});组件C 通过B组件传递过来的$attr属性获取messagec,B通过$listener监听C的事件,再转发给A组件上面两种方式都是父子关系，如果是兄弟关系呢？EventBus事件总线对于非父子关系的组件，如果用前面说到的两种方式需要通过共同的父级作为中间人来进行沟通，非常麻烦。可以通过创建一个全局的Vue实例，并使用他的$emit和$on来完成兄弟组件间的通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 组件 AVue.component('A', { template: ` &lt;div&gt; &lt;p&gt;this is A component!&lt;/p&gt; &lt;input type=\"text\" v-model=\"mymessage\" @input=\"passData(mymessage)\"&gt; &lt;/div&gt; `, data() { return { mymessage: 'hello brother1' } }, methods: { passData(val) { //触发全局事件globalEvent this.$EventBus.$emit('globalEvent', val) } }});// 组件 BVue.component('B', { template:` &lt;div&gt; &lt;p&gt;this is B component!&lt;/p&gt; &lt;p&gt;组件A 传递过来的数据：{{brothermessage}}&lt;/p&gt; &lt;/div&gt; `, data() { return { mymessage: 'hello brother2', brothermessage: '' } }, mounted() { //绑定全局事件globalEvent this.$EventBus.$on('globalEvent', (val) =&gt; { this.brothermessage = val; }); }});//定义中央事件总线const EventBus = new Vue();// 将中央事件总线赋值到 Vue.prototype 上，这样所有组件都能访问到了Vue.prototype.$EventBus = EventBus;const app = new Vue({ el: '#app', template: ` &lt;div&gt; &lt;A /&gt; &lt;B /&gt; &lt;/div&gt; `});原理很简单，不多赘述provide 和 inject父组件使用provider暴露需要传递的属性，所有子元素，无论层级有多深，都能通过inject来获取这个属性。1234567891011121314151617181920212223242526272829303132333435363738394041// 定义 parent 组件Vue.component('parent', { template: ` &lt;div&gt; &lt;p&gt;this is parent component!&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide: { for:'test' }, data() { return { message: 'hello' } }});// 定义 child 组件Vue.component('child', { template: ` &lt;div&gt; &lt;input type=\"tet\" v-model=\"mymessage\"&gt; &lt;/div&gt; `, inject: ['for'], // 得到父组件传递过来的数据 data(){ return { mymessage: this.for } },});const app = new Vue({ el: '#app', template: ` &lt;div&gt; &lt;parent /&gt; &lt;/div&gt; `});","link":"/2020/09/08/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"title":"【前端】vue权限管理","text":"需求后台管理界面不同的用户根据角色的不同显示不同的功能模块前端页面能够在任一模块下添加子路由，并能够配置权限按钮权限控制实现思路用户登录的时，获取用户token,在跳转到主页面时根据用户token向后端请求对应的路由表，前端根据路由表与本地已导入的模块对比，双方都存在的情况下动态生成路由通过router.addRoutes方法载入。代码实现将模块导入与router初始化分离成两个js文件来管理，在原有的router目录下操作新建components文件夹用于导入模块123456789101112131415161718192021222324// 框架页const home = () =&gt; import('@/page/home')//* **********************//// 模块界面// 系统管理模块const SystemManagement = () =&gt; import('@/page/modules/system-management')//* **********************//// 系统基础设置模块const SystemInfrastructure = () =&gt; import('@/page/modules/system-infrastructure')// 用户管理模块const User = () =&gt; import('@/page/modules/system-infrastructure/user')// 单位管理const Unit = () =&gt; import('@/page/modules/system-infrastructure/unit')// 菜单管理const Menu = () =&gt; import('@/page/modules/system-infrastructure/menu')// 权限管理const Permission = () =&gt; import('@/page/modules/system-infrastructure/permission')// 系统字典const SystemDictionary = () =&gt; import('@/page/modules/system-infrastructure/ system-dictionary')// 路由添加页面const RouteAdd = () =&gt; import('@/page/modules/system-infrastructure/router')export { SystemManagement,RouteAdd,home,SystemDictionary,Permission,Unit,Menu,User,SystemInfrastructure}修改router/index.js使用router.beforeEach()与router.addRoutes()动态添加路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import Vue from 'vue'import VueRouter from 'vue-router'import store from '@/store'import { setLocalStorage, getLocalStorage, createRoutes, base64 } from '@/common/js/util.js'import { MessageBox } from 'element-ui'import * as components from './components'// 获取push方法const originalPush = VueRouter.prototype.push// 重写push方法、处理路由重复点击的错误VueRouter.prototype.push = function push(location) { return originalPush.call(this, location).catch(err =&gt; {console.warn(`路由跳转了两次，请尝试给点击事件添加.stop修饰符`)})}const routes = [ { path:'/', redirect: '/login' }, { path: '/login', name: 'login', component: login }]const errorRoutes = [ // 匹配不到的页面，会显示err页 { path: '*', name: 'error', component: NotFound }]// 实例化路由const createRouter = () =&gt; { return new VueRouter({ routes })}const router = createRouter()// 在添加路由前，先将原有的路由清空，避免vue警告router.$addRoutes = (params)=&gt;{ router.matcher = createRouter().matcher; // 先添加登录页面、在添加404页面 否则所有路由都会匹配到err页面 router.addRoutes(params) router.addRoutes(errorRoutes)}router.beforeEach(async (to, from, next) =&gt; { // 路由是否跳向login if(to.name == 'login') { next() } else if(to.name != 'login'){ // 检查vuex中是否存在路由如果存在直接跳转 const hasRoutes = store.getters.dynamicRoutes.length &gt; 0 if(hasRoutes) { next() return } else { try { // 调用 vuex action 获取路由表 await store.dispatch('getDynamicRouters') // 获取路由表并解耦，否则会报错 let dynamicRoutes = JSON.parse(JSON.stringify(store.getters.dynamicRoutes)) // 创建路由 dynamicRoutes = createRoutes(dynamicRoutes, components) // 添加路由 router.$addRoutes(dynamicRoutes) // 路由加密缓存，这里可以使用其他对称加密方式 const cache = base64.encode(JSON.stringify(dynamicRoutes)) setLocalStorage('cacheRoutes', cache) // 跳转路由 next({path:to.path}) }catch (e) { console.log(e) } } }})几个问题路由缓存： 上面代码中本地的路由缓存并没起作用，因为这里后端已经使用redis缓存了， 前端没有再缓存的必要，用户刷新页面后直接按照存在localstrage的token重新获取即可，也不会出现白屏的情况push方法报错： 动态路由往往都是使用递归组件来渲染侧边栏的，有时候点击事件会触发两次，这时候vue就会报路由重复跳转的错误，这里利用catch截取了错误，并提示。登出功能： 登出是在其他页面实现的，清除本地的token和路由缓存返回登录页即可createRoutes方法：1234567891011121314151617181920// routes是后台传给前端的路由表export const createRoutes = (routes, components) =&gt; { routes.forEach((item, index) =&gt; { // 检查前端是否存在此模块 if (components[item.model]) { // 存在的话将模块挂载到这个对象下 item.component = components[item.model] // 检查是否还有子路由 if (item.children) { // 递归调用 createRoutes(item.children, components) } // 不存在此模块则删除这条路由，并且发出错误警告 } else { routes.splice(index, 1) console.error(`model:${item.model}在本地路由表src/router/components中未找到,请确认是否创建${item.model}并引入！`) } }) return routes}路由格式：相比其他的动态路由方案，个人不习惯使用vueaccessctrl,用户没权限的页面直接不加载显示就行了,没必要给个meta进行判断，当然这也只是我初步实践下的粗浅的结论。实际上我也是跟后端大大商量着预留了meta字段，防止以后真香，这里就没写出来1234567891011121314{ path: '/home', model: 'home', icon: '', text: '首页', children: [ { path: '', name: 'SystemManagement', model: 'SystemManagement', text: '系统管理', icon: '' }}递归组件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!-- * @Descripttion: * @version: * @Author: xzq * @Date: 2020-10-28 17:54:17 * @LastEditors: xzq * @LastEditTime: 2020-10-30 14:38:15--&gt;&lt;template&gt; &lt;div class=&quot;slidebar&quot;&gt; &lt;template v-for=&quot;(item,index) in data&quot;&gt; &lt;el-submenu :key=&quot;index&quot; v-if=&quot;item.children&quot; :index=&quot;baseRoute+'/'+item.path&quot; @click.self=&quot;selectItem(item,baseRoute)&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span&gt;{{item.text}}&lt;/span&gt; &lt;/template&gt; &lt;slidebar :data=&quot;item.children&quot; :lastIndex=&quot;index&quot; :baseRoute=&quot;getCurrentLinkUrl(baseRoute, item.path)&quot; &gt;&lt;/slidebar&gt; &lt;/el-submenu&gt; &lt;el-menu-item v-else :key=&quot;index&quot; @click.self=&quot;selectItem(item,baseRoute)&quot; :index=&quot;baseRoute+'/'+item.path&quot;&gt; &lt;i :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;{{item.text}}&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'slidebar', props: { // 用于指定初次遍历时的index, 不需要修改 lastIndex: { default: () =&gt; { return 0 } }, // 指定动态路由表传入时，你想显示的顶部路由，比如这里的顶部路由就是/home baseRoute: { default: () =&gt; { return '' } }, data: { default: [] } }, methods: { getCurrentIndex (last, now) { if (!last || last === '') { return now + '' } return `${last}-${now}` }, getCurrentLinkUrl (last, now) { if (!last || last === '') { return `/home/${now}` } return `${last}/${now}` }, selectItem (item, baseRoute) { this.$bus.$emit('selectItem', item, baseRoute) } }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt;组件使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot; &gt; &lt;el-menu default-active=&quot;0&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; ref=&quot;elMenu&quot; &gt; &lt;slidebar :data=&quot;dynamicRoutes[0].children&quot; :last-index=&quot;''&quot; :base-route=&quot;'/home'&quot; /&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;el-row class=&quot;header&quot;&gt; &lt;el-col :span=&quot;4&quot; :offset=&quot;18&quot; &gt; &lt;el-select v-model=&quot;value&quot; multiple filterable remote :clearable=&quot;true&quot; reserve-keyword placeholder=&quot;请输入关键词&quot; :remote-method=&quot;remoteMethod&quot; :loading=&quot;loading&quot; &gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; &gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters, mapActions } from 'vuex'import slidebar from '@/base/slidebar/slidebar.vue'export default { data () { return { data: '', options: [], value: '', loading: '' } }, mounted () { this.$bus.$on('selectItem', (item, route) =&gt; { this.$router.push({ path: route + '/' + item.path }) console.log(this.$route) }) }, methods: { handleOpen (key, keyPath) { }, handleClose (key, keyPath) { }, ...mapActions(['getDynamicRouters']), remoteMethod () { } }, computed: { ...mapGetters(['dynamicRoutes']) }, components: { slidebar }}&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;.home { height: 100%; width: 100%; .el-container { height: 100%; .el-aside { height: 100%; .el-menu-vertical-demo { height: 100%; } } }}.el-header { background-color: #B3C0D1; color: #333; line-height: 60px; }&lt;/style&gt;按钮权限通过指令或者全局方法的形式，用户登录时，将用户的权限存储在vuex中，在按钮中使用字符串、数组、对象的方式来判断用户是否拥有此按钮的权限在登陆时将用户权限信息存储到vuex，定义为permissionList判断用户是否拥有权限util.js12345678910111213141516171819202122232425export const getObjectType = (object) =&gt; { return Object.prototype.toString.call(object)}// roles：用户权限 permission：模块查看所需的权限export const hasPermission = (roles, permission)=&gt;{ // roles为空直接返回false if (roles === '' || roles.length &lt;= 0 || JSON.stringify(roles) === '{}') return false const type = getObjectType(permission) // 当v-permisson 传入字符串时 if (type === '[object String]') { if(permission === '') return false return roles.findIndex(item=&gt;{ return item === permission }) &gt; -1 } else { // 当 v-permisson 传入其他值时，一律转成JSON字符串再对比 const per = JSON.stringify(permission) console.log(per) if(permission === '[]' || permission === '{}') return false return roles.findIndex(item=&gt;{ return permission.indexOf(item) &gt; -1 }) &gt; -1 }}指令以及全局方法的编写v-permission $permisson1234567891011121314151617181920212223242526272829303132333435import { hasPermission } from './util'import store from '@/store'const permissionHandle = (el, binding) =&gt; { // 我们写代码时给组件绑定的权限 const permissions = binding.value // 从vuex中获取用户权限 const permissionList = store.getters.permissionList // console.log(permissions) if (!hasPermission(permissionList, permissions)) { el.classList.add('p_hide') } else { el.classList.remove('p_hide') }}/* .p_hide { display: none; } */export default { // 使用install方法，方便vue.use()使用 install (Vue) { // 前端编写时限定的权限 Vue.prototype.$permission = function (permissions) { // 获取用户权限列表 const permissionList = this.$store.state.permissionList // 检查用户权限 return hasPermission(permissionList, permissions) } Vue.directive('permission', { inserted: permissionHandle, update: permissionHandle }) }}对于某些技术型用户，可能会审查元素把p_hide删掉，使得按钮能正常使用，所以如果按钮涉及到权限，最好在js中使用$permisson鉴权后再继续请求，后端也需要通过token来确定此用户是否有此权限，如果没有则拦截请求，并返回信息给前端。","link":"/2020/11/01/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91vue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0-1/"},{"title":"【前端】webpack5实现微服务实践及其新特性","text":"WEBPACK5持久化缓存如果文件有变化则重新编译，否则直接使用缓存1、 持久化缓存原生支持文件类型的打包不需要再引入其他loader123456789101112131415161718{ test: /\\.png$/, type: 'asset/resource', // fileLoader}, { test: /\\.ico$/, type: 'asset/inline', // url-loader 模块大小小于limit base64 字符串}, { test: /\\.txt$/, type: 'asset/source', // raw-loader 源文件打包 不处理文件}, { test: /\\.jpg$/, // 小于4kb时，转换为base64直接插入到页面中 type: 'asset', parser: { dataUrlCondition: { maxSize: 4 * 1024 } }}支持URLs支持URLs 在请求中访问协议12import data from 'data:text/javasript, export default \"title\"'console.log('data:', data)moduleIds &amp;&amp; chunkIds 的优化1234optimization: { moduleIds: 'named', // deterministic natural named chunkIds: 'named'}module: 每一个文件其实都可以看成一个modulechunk：webpack打包乾最终生成的代码块，代码块会生成文件，一个文件对应一个chunk再webpack5之前，没有从entry打包的chunk文件都会一1，2，3的文件命名方式输出，删除某些文件可能会导致缓存失效再生产模式下，默认启用这些功能chunkIds: “deterministic”,moduleIds: 5. 5.“detetministic”此算法采用确定性的方式将短数字ID3-4个字符短hash值分配给module和chunkschunkId设置为deterministic， 则output中chunkFilenmae里的【name】会被替换成确定性的短数字ID虽然chunkId不变，（无论值是：deterministic | natural | named） 但更改chunk内容，chunkhash还是会改变的可选值含义示例deterministic根据模块名称生成简短的hash值915named方便调试的高可读性idsrc_two_js.jsnatural按使用顺序的数字ID1size根据模块大小生成数字ID0移除了NODE.js 的polyfillwebpack4带了许多node.js核心模块的polyfill,一旦模块中使用了任何核心模块，比如(crypto) 这些模块就会被自动启用webpack5不再自动引入这些polyfillnpm install crypto-js crypto-browserify stream-browserify buffer -D在页面中使用时报错1234567891011ERROR in ./node_modules/cipher-base/index.js 2:16-43Module not found: Error: Can't resolve 'stream' in 'E:\\project\\webpack5\\node_modules\\cipher-base'BREAKING CHANGE: webpack &lt; 5 used to include polyfills for node.js core modules by default.This is no longer the case. Verify if you need this module and configure a polyfill for it.If you want to include a polyfill, you need to: - add a fallback 'resolve.fallback: { \"stream\": require.resolve(\"stream-browserify\") }' - install 'stream-browserify'If you don't want to include a polyfill, you can use an empty module like this: resolve.fallback: { \"stream\": false }webpack5现在需要需要自己添加polyfillmodule.export.resolve1234567resolve: { fallback: { crypto: require.resolve(\"crypto-browserify\"), stream: require.resolve(\"stream-browserify\"), buffer: require.resolve('buffer') } },如果不使用这个polyfill,直接使用false1234567resolve: { fallback: { crypto: false, stream: false, buffer: false } },webpack作者设计的意图原本时打包后台文件，所以默认是会自动加上polyfill的，而现在主要用于前端项目的打包，所以就将原来自动加载polyfill部分的功能移除了，减少打包的体积更加强大的 tree-shakingtre-shaking 就在打包时，剔除没有使用到的代码webpack4 本身的treeshaking 比较简单，主要是找一个import进来的变量是否在这个模块中出现过webpack5可以根据自身作用域之间的关系来进行优化webpack-deep-scope-demomodules1.js1234567import { fun3 } from './module2'export function fun1 () { console.log('this fun1')}export function fun2 () { console.log('this fun2' + fun3)}modules2.js1234567export function fun3 () { console.log('this fun3')}export function fun4 () { console.log('this fun4')}index.js123import { fun1 } from './modules/module1'console.log(fun1)webpack配置module.exports.12345optimization: { usedExports: true, // 标注使用到的导出 moduleIds: 'named', // deterministic natural named chunkIds: 'named' },sideEffects函数副作用指当调用函数时，除了返回函数值之外，还产生了附加的影响，例如修改全局变量严格的函数式语言要求函数必须无副作用title.js12345document.title = 'getTitle'export function getTitle(params) { console.log('getTitle')}index.js1import './modules/title'webpack.config.jsmodule.export =123456{ optimization: { usedExports: true, // 标注使用到的导出 moduleIds: 'named', // deterministic natural named chunkIds: 'named'}package.json1234{ \"sideEffects\": false || true, //这个选项默认是true}为true时打包结果为：1(()=&gt;{\"use strict\";document.title=\"getTitle\"})();为false时打包结果为空12可以使用正则字符串来定义忽略sideEffects的文件，这里忽略了css文件package.json123{ \"sideEffects\": [\"*.css\"],}配置完以上内容，可以发现，样式还保留着，但是gettitle的全局设置并没有生效module 模块联邦配置参数字段类型含义namestring输出的模块名，被远程引用时路径为${name}/${expose}libraryobject声明全局变量的方式，name为umd的namefilenamestring构建输出的文件名remotesObject远程引用的应用名以及其别名的映射，使用时以key值做为nameexposesobject被远程引用时可暴露的资源路径及其别名sharedobject与其他应用之间可以共享的第三方依赖，使你的代码中不需要重复加载同一份依赖主服务配置这里的主服务只用于模块共享，环境共享123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')module.exports = { cache: { type: 'filesystem', // 默认是memory cacheDirectory: path.resolve(__dirname,'/node_modules/.cache/webpack') }, mode: 'development', devtool: false, entry: './src/index.js', optimization: { usedExports: true, // 标注使用到的导出 moduleIds: 'named', // deterministic natural named chunkIds: 'named' }, resolve: { fallback: { crypto: require.resolve(\"crypto-browserify\"), stream: require.resolve(\"stream-browserify\"), buffer: require.resolve('buffer') } }, devServer: { port: 8080 }, output: { filename: '[name].js', chunkFilename: '[name].js', publicPath: 'http://localhost:8080/' }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/g, use: [ { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } ] }, { test: /\\.css$/, exclude: /node_modules/g, use: [ 'style-loader','css-loader' ] }, { test: /\\.png$/, type: 'asset/resource', // fileLoader }, { test: /\\.ico$/, type: 'asset/inline', // url-loader 模块大小小于limit base64 字符串 }, { test: /\\.txt$/, type: 'asset/source', // raw-loader 源文件打包 不处理文件 }, { test: /\\.jpg$/, // 小于4kb时，转换为base64直接插入到页面中 type: 'asset', parser: { dataUrlCondition: { maxSize: 4 * 1024 } } } ] }, plugins: [ new HtmlWebpackPlugin({ template: './public/index.html' }), new ModuleFederationPlugin({ name: 'mainVariable', // 远程仓库的名字 向外暴漏的全局变量名 filename: 'mainEntry.js', // 构建出的文件名 exposes: { './NewsList': './src/NewList' } }) ]}微应用配置这里的微应用指的是每个依赖于主服务组件的其他应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')module.exports = { cache: { type: 'filesystem', // 默认是memory cacheDirectory: path.resolve(__dirname,'/node_modules/.cache/webpack') }, mode: 'development', devtool: false, entry: './src/index.js', optimization: { usedExports: true, // 标注使用到的导出 moduleIds: 'named', // deterministic natural named chunkIds: 'named' }, resolve: { fallback: { crypto: require.resolve(\"crypto-browserify\"), stream: require.resolve(\"stream-browserify\"), buffer: require.resolve('buffer') } }, devServer: { port: 8081 }, output: { filename: '[name].js', chunkFilename: '[name].js', publicPath: 'http://localhost:8081/' }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/g, use: [ { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', '@babel/preset-react' ] } } ] }, { test: /\\.css$/, exclude: /node_modules/g, use: [ 'style-loader','css-loader' ] }, { test: /\\.png$/, type: 'asset/resource', // fileLoader }, { test: /\\.ico$/, type: 'asset/inline', // url-loader 模块大小小于limit base64 字符串 }, { test: /\\.txt$/, type: 'asset/source', // raw-loader 源文件打包 不处理文件 }, { test: /\\.jpg$/, // 小于4kb时，转换为base64直接插入到页面中 type: 'asset', parser: { dataUrlCondition: { maxSize: 4 * 1024 } } } ] }, plugins: [ new HtmlWebpackPlugin({ template: './public/index.html' }), new ModuleFederationPlugin({ name: 'app', remotes: { // 远程仓库的名字@远程仓库暴露组件的地址 main: 'mainVariable@http://localhost:8080/mainEntry.js' }, shared: ['react','react-dom'] //主服务与微服务之间只要有一个加载了这两个库，就不会重复加载 }) ]}","link":"/2021/01/31/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91webpack5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%BB%A5%E5%8F%8A%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"【老掉牙】thymeleaft3 基本语法","text":"记录基本的语法，方便以后使用时查看，thmeleaf共有1~8个优先级数字越低优先级越高，使用时需要注意常用属性介绍1、 th:text order= 7设置当前元素的文本内容，相同功能的有th:utext,两者的区别在于th:text：只会将文本原原本本的转化，不会渲染文本中的html标签1&lt;p th:text=\"${text}\"&gt;&lt;/p&gt;th:utext：会渲染html标签1&lt;p th:utext=\"${text}\"&gt;&lt;/p&gt;VUEv-text:v-html:angularjsng-bind: //并不完全只有转化文本的功能，还能单向绑定修改元素的值ng-bind-html:2、th:value order= 6设置当前元素的value值，类似于修改指定属性的还有th:src,th:href1&lt;input th:value=\"${value}\"&gt;&lt;/input&gt;VUEv-src:v-value:事实上，在vue中只要在需要绑定的属性前，加上:就能够动态的修改这个属性的值angualrjsng-src:在angualrjs中也只需要在需要修改的属性前加上 ng前缀3、th:each order= 2遍历循环属性，通常与 th:text,th:value一起使用1234567&lt;div th:each=\"message : ${eachlist}\"&gt; &lt;p th:text=\"${message}\"&gt; &lt;/p&gt;&lt;/div&gt;&lt;!-- 使用方法二 --&gt;&lt;div&gt; &lt;!--只遍历p，推荐使用--&gt; &lt;p th:text=\"${message}\" th:each=\"message : ${thEach}\" /&gt;&lt;/div&gt;VUEv-for: 需要在循环的最外层标签上添加 :key 来确保v-for能够按你预想的顺序来遍历数据anguarjsng-repeat: 一般会加上 track by $index 但是不像 vue 需要强制加上。4、th:if order= 3条件判断类似的还有th:unless，th:swith，th:case1&lt;p th:text=\"${thIf}\" th:if=\"${not #strings.isEmpty(thIf)}\"&gt;&lt;/p&gt;VUEv-if: 控制元素是否渲染，与v-show使用效果基本一样但是v-show只是 display: nonev-else:v-elese-if:angularjsng-if: 与vue使用方法效果一致ng-else:ng-else-if:5、th:insert order= 1插入代码块，类似的还有th:replace,th:includeth:insert：将代码块片段整个插入到使用了th:insert的HTML标签中，th:replace：将代码块片段整个替换使用了th:replace的HTML标签中，th:include：将代码块片段包含的内容插入到使用了th:include的HTML标签中，1&lt;div th:insert=\"~{grammar/common::thCommon}\"&gt;&lt;/div&gt;12345678910111213141516171819202122232425&lt;!-- 使用th:fragment来创建代码块 --&gt;&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2019 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!-- 代码块的使用 --&gt;&lt;!--三种不同的引入方式--&gt;&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;&lt;!-- 三种方式最终呈现效果的区别 --&gt;&lt;!--th:insert是在div中插入代码块，即多了一层div--&gt;&lt;div&gt; &lt;footer&gt; &amp;copy; 2019 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;!--th:replace是将代码块代替当前div，其html结构和之前一致--&gt;&lt;footer&gt; &amp;copy; 2019 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--th:include是将代码块footer的内容插入到div中，即少了一层footer--&gt;&lt;div&gt; &amp;copy; 2019 The Good Thymes Virtual Grocery&lt;/div&gt;&lt;!-- 使用th:fragment方式定义的代码块可以使用三种方式引用，只是插入的效果不同 --&gt;VUE在vue中，使用组件template的形式定义代码块，使用components注册后，可以直接在需要的地方把组件名当html标签放到需要的地方。angularjs使用自定义指令directive来定义代码块，共有AEC 三种形式的组件，直接当作标签，或注释，标签属性，来使用6、th:fragment order= 8定义代码块，方便被th:insert引用VUEangularjs7、 th:object order= 4声明变量，一般与*{}一起使用12345&lt;div th:object=\"${thObject}\"&gt; &lt;p&gt;ID: &lt;span th:text=\"*{id}\" /&gt;&lt;/p&gt;&lt;!--th:text=\"${thObject.id}\"--&gt; &lt;p&gt;TH: &lt;span th:text=\"*{thName}\" /&gt;&lt;/p&gt;&lt;!--${thObject.thName}--&gt; &lt;p&gt;DE: &lt;span th:text=\"*{desc}\" /&gt;&lt;/p&gt;&lt;!--${thObject.desc}--&gt;&lt;/div&gt;VUEv-model: //在js中必须先定义，否则无法使用::angularjsng-model: //在angularjs中推荐在js中先定义，再绑定到htmlng-init: //声明变量8、th:attr修改任意属性，很少使用9、java负责给前端传输变量12345678910111213141516171819202122import com.itdragon.entities.ThObject;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.Arrays;import java.util.List;@Controllerpublic class ThymeleafController { @RequestMapping(\"thymeleaf\") public String thymeleaf(ModelMap map) { map.put(\"thText\", \"th:text 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;\"); map.put(\"thUText\", \"th:utext 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;\"); map.put(\"thValue\", \"thValue 设置当前元素的value值\"); map.put(\"thEach\", Arrays.asList(\"th:each\", \"遍历列表\")); map.put(\"thIf\", \"msg is not null\"); map.put(\"thObject\", new ThObject(1L, \"th:object\", \"用来偷懒的th属性\")); return \"grammar/thymeleaf\"; }}二、标准表达式1、${} 变量表达式可以获取对象的属性和方法可以使用ctx：上下文对象vars：上下文变量locale：上下文的语言环境request：（仅在web上下文)的HttpServletRequest对象response：（仅在web上下文）的HttpServletResponse对象session：（仅在web上下文）的session对象servletContext：（仅在web上下文）ServletContex 内置对象12// java 代码将用户名放在session中session.setAttribute(\"userinfo\",username);12&lt;!-- Thymeleaf通过内置对象直接获取 --&gt;th:text=\"${session.userinfo}\"可以使用dates：日期方法，常用的方法有：format，year，month，hour，createNow等numbers：数据格式化方法，常用的方法有：formatDecimalstrings：字符串格式化方法：在javaString对象有的方法他基本都有equalsequalslgnoreCaselengthtrimtoUpperCasetoLowerCaseindexOfsubstringreplacestartsWithendsWithcontainscontainslgnoreCaseobjects：arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等lists：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等使用实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ITDragon Thymeleaf 内置方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ITDragon Thymeleaf 内置方法&lt;/h2&gt; &lt;h3&gt;#strings &lt;/h3&gt; &lt;div th:if=\"${not #strings.isEmpty(itdragonStr)}\" &gt; &lt;p&gt;Old Str : &lt;span th:text=\"${itdragonStr}\"/&gt;&lt;/p&gt; &lt;p&gt;toUpperCase : &lt;span th:text=\"${#strings.toUpperCase(itdragonStr)}\"/&gt;&lt;/p&gt; &lt;p&gt;toLowerCase : &lt;span th:text=\"${#strings.toLowerCase(itdragonStr)}\"/&gt;&lt;/p&gt; &lt;p&gt;equals : &lt;span th:text=\"${#strings.equals(itdragonStr, 'itdragonblog')}\"/&gt;&lt;/p&gt; &lt;p&gt;equalsIgnoreCase : &lt;span th:text=\"${#strings.equalsIgnoreCase(itdragonStr, 'itdragonblog')}\"/&gt;&lt;/p&gt; &lt;p&gt;indexOf : &lt;span th:text=\"${#strings.indexOf(itdragonStr, 'r')}\"/&gt;&lt;/p&gt; &lt;p&gt;substring : &lt;span th:text=\"${#strings.substring(itdragonStr, 2, 8)}\"/&gt;&lt;/p&gt; &lt;p&gt;replace : &lt;span th:text=\"${#strings.replace(itdragonStr, 'it', 'IT')}\"/&gt;&lt;/p&gt; &lt;p&gt;startsWith : &lt;span th:text=\"${#strings.startsWith(itdragonStr, 'it')}\"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=\"${#strings.contains(itdragonStr, 'IT')}\"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#numbers &lt;/h3&gt; &lt;div&gt; &lt;p&gt;formatDecimal 整数部分随意，小数点后保留两位，四舍五入: &lt;span th:text=\"${#numbers.formatDecimal(itdragonNum, 0, 2)}\"/&gt;&lt;/p&gt; &lt;p&gt;formatDecimal 整数部分保留五位数，小数点后保留两位，四舍五入: &lt;span th:text=\"${#numbers.formatDecimal(itdragonNum, 5, 2)}\"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#bools &lt;/h3&gt; &lt;div th:if=\"${#bools.isTrue(itdragonBool)}\"&gt; &lt;p th:text=\"${itdragonBool}\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#arrays &lt;/h3&gt; &lt;div th:if=\"${not #arrays.isEmpty(itdragonArray)}\"&gt; &lt;p&gt;length : &lt;span th:text=\"${#arrays.length(itdragonArray)}\"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=\"${#arrays.contains(itdragonArray, 5)}\"/&gt;&lt;/p&gt; &lt;p&gt;containsAll : &lt;span th:text=\"${#arrays.containsAll(itdragonArray, itdragonArray)}\"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#lists &lt;/h3&gt; &lt;div th:if=\"${not #lists.isEmpty(itdragonList)}\"&gt; &lt;p&gt;size : &lt;span th:text=\"${#lists.size(itdragonList)}\"/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=\"${#lists.contains(itdragonList, 0)}\"/&gt;&lt;/p&gt; &lt;p&gt;sort : &lt;span th:text=\"${#lists.sort(itdragonList)}\"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#maps &lt;/h3&gt; &lt;div th:if=\"${not #maps.isEmpty(itdragonMap)}\"&gt; &lt;p&gt;size : &lt;span th:text=\"${#maps.size(itdragonMap)}\"/&gt;&lt;/p&gt; &lt;p&gt;containsKey : &lt;span th:text=\"${#maps.containsKey(itdragonMap, 'thName')}\"/&gt;&lt;/p&gt; &lt;p&gt;containsValue : &lt;span th:text=\"${#maps.containsValue(itdragonMap, '#maps')}\"/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#dates &lt;/h3&gt; &lt;div&gt; &lt;p&gt;format : &lt;span th:text=\"${#dates.format(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;custom format : &lt;span th:text=\"${#dates.format(itdragonDate, 'yyyy-MM-dd HH:mm:ss')}\"/&gt;&lt;/p&gt; &lt;p&gt;day : &lt;span th:text=\"${#dates.day(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;month : &lt;span th:text=\"${#dates.month(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;monthName : &lt;span th:text=\"${#dates.monthName(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;year : &lt;span th:text=\"${#dates.year(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;dayOfWeekName : &lt;span th:text=\"${#dates.dayOfWeekName(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;hour : &lt;span th:text=\"${#dates.hour(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;minute : &lt;span th:text=\"${#dates.minute(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;second : &lt;span th:text=\"${#dates.second(itdragonDate)}\"/&gt;&lt;/p&gt; &lt;p&gt;createNow : &lt;span th:text=\"${#dates.createNow()}\"/&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;后台代码1234567891011121314@RequestMapping(\"varexpressions\")public String varexpressions(ModelMap map) { map.put(\"itdragonStr\", \"itdragonBlog\"); map.put(\"itdragonBool\", true); map.put(\"itdragonArray\", new Integer[]{1,2,3,4}); map.put(\"itdragonList\", Arrays.asList(1,3,2,4,0)); Map itdragonMap = new HashMap(); itdragonMap.put(\"thName\", \"${#...}\"); itdragonMap.put(\"desc\", \"变量表达式内置方法\"); map.put(\"itdragonMap\", itdragonMap); map.put(\"itdragonDate\", new Date()); map.put(\"itdragonNum\", 888.888D); return \"grammar/varexpressions\";}2、@{} 链接表达式无论时静态资源的引用，form表单的请求，凡是链接都可以用@{}。这样可以动态控制项目路径，即便项目路径目录变了，依然可以正常访问1server.context-path=/xxx链接表达式结构无参：@{xxx},有参：@{/xxx{k=v1,k2=v2}}对应的URL结构：@{xxx?k=v1&amp;k2=v2}引入本地资源：@{/项目本地的路径资源}引入外部资源：@{/webjars/资源在jar包中的路径}12345&lt;link th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" rel=\"stylesheet\"&gt;&lt;link th:href=\"@{/main/css/itdragon.css}\" rel=\"stylesheet\"&gt;&lt;form class=\"form-login\" th:action=\"@{/user/login}\" th:method=\"post\" &gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/login.html(l='zh_CN')}\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@{/login.html(l='en_US')}\"&gt;English&lt;/a&gt;3、#{} 消息表达式消息表达式一般用于国际化的场景th:text=&quot;#{msg}&quot;。4、~{} 代码块表达式支持两种语法结构推荐：~{templatename::fragmentname}支持：~{templatename::#id}5、*{} 选择变量表达式多用于和th:object结合使用Thymeleaf在SpringBoot应用Thymeleaf是Spring Boot官方推荐使用的模版引擎，这也意味着用Thymeleaf比其他模版引擎更简单。开发步骤：第一步：引入Thymeleaf依赖第二步：提取公共页面，提高代码的重用性，统一页面风格第三步：页面显示和国际化功能引入Thymeleaf，pom.xml 引入Thymeleaf的依赖，并确定其版本12345678910111213&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--引入模版引擎thymeleaf--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;提取公共页面为了统一页面风格，提高页面的复用率，我们一般都会提取公共页面。之前在文章中介绍了SiteMesh的使用，今天用Thymeleaf来实现。统一规范引入的资源文件123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head th:fragment=\"common-head\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width, user-scalable=no\" /&gt; &lt;title&gt;ITDragon系统&lt;/title&gt; &lt;link type=\"image/x-icon\" href=\"images/favicon.ico\" rel=\"shortcut icon\"&gt; &lt;link th:href=\"@{/sb-admin-1.0.4/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt; &lt;link th:href=\"@{/sb-admin-1.0.4/css/sb-admin.css}\" rel=\"stylesheet\"&gt; &lt;link th:href=\"@{/sb-admin-1.0.4/css/plugins/morris.css}\" rel=\"stylesheet\"&gt; &lt;link th:href=\"@{/sb-admin-1.0.4/font-awesome/css/font-awesome.min.css}\" rel=\"stylesheet\"&gt; &lt;script th:src=\"@{/sb-admin-1.0.4/js/jquery.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/sb-admin-1.0.4/js/bootstrap.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/sb-admin-1.0.4/js/plugins/morris/raphael.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/sb-admin-1.0.4/js/plugins/morris/morris.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/sb-admin-1.0.4/js/plugins/morris/morris-data.js}\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt;统一左侧菜单栏1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;header id=\"header\" th:fragment=\"common-header\"&gt; &lt;!-- Navigation --&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-ex1-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/dashboard\"&gt;ITDragon sb-admin-1.0.4&lt;/a&gt; &lt;/div&gt; &lt;!--和知识点没关系的代码，这里就补贴出来了，完整代码请异步github--&gt; &lt;!-- Sidebar Menu Items - These collapse to the responsive navigation menu on small screens --&gt; &lt;div class=\"collapse navbar-collapse navbar-ex1-collapse\"&gt; &lt;ul class=\"nav navbar-nav side-nav itdragon-nav\"&gt; &lt;li th:class=\"${activeUrl=='dashboard'?'nav-link active':'nav-link'}\"&gt; &lt;a th:href=\"@{/dashboard}\"&gt;&lt;i class=\"fa fa-fw fa-dashboard\"&gt;&lt;/i&gt; Dashboard&lt;/a&gt; &lt;/li&gt; &lt;li th:class=\"${activeUrl=='employees'?'nav-link active':'nav-link'}\"&gt; &lt;a th:href=\"@{/employees}\"&gt;&lt;i class=\"fa fa-fw fa-bar-chart-o\"&gt;&lt;/i&gt; Employees&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- /.navbar-collapse --&gt; &lt;/nav&gt;&lt;/header&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2019/09/02/thymeleaf3%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"funllscreen","slug":"funllscreen","link":"/tags/funllscreen/"},{"name":"es5","slug":"es5","link":"/tags/es5/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"git备份","slug":"git备份","link":"/tags/git%E5%A4%87%E4%BB%BD/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"office2010","slug":"office2010","link":"/tags/office2010/"},{"name":"计算机二级","slug":"计算机二级","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%8C%E7%BA%A7/"},{"name":"OSS","slug":"OSS","link":"/tags/OSS/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"图床配置","slug":"图床配置","link":"/tags/%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"基础语法","slug":"基础语法","link":"/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"metingJs","slug":"metingJs","link":"/tags/metingJs/"},{"name":"aplayer","slug":"aplayer","link":"/tags/aplayer/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"LINUX","slug":"LINUX","link":"/tags/LINUX/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"内网穿透","slug":"内网穿透","link":"/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"酸酸乳","slug":"酸酸乳","link":"/tags/%E9%85%B8%E9%85%B8%E4%B9%B3/"},{"name":"youtube","slug":"youtube","link":"/tags/youtube/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"移动端适配","slug":"移动端适配","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"属性兼容","slug":"属性兼容","link":"/tags/%E5%B1%9E%E6%80%A7%E5%85%BC%E5%AE%B9/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"+ tools + 实用工具","slug":"tools-实用工具","link":"/tags/tools-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"github page","slug":"github-page","link":"/tags/github-page/"},{"name":"域名","slug":"域名","link":"/tags/%E5%9F%9F%E5%90%8D/"},{"name":"thymeleaft3","slug":"thymeleaft3","link":"/tags/thymeleaft3/"}],"categories":[{"name":"hexo Travis github-action","slug":"hexo-Travis-github-action","link":"/categories/hexo-Travis-github-action/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"jQuery","slug":"jQuery","link":"/categories/jQuery/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"工具合集","slug":"工具合集","link":"/categories/%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"科学上网 linux","slug":"科学上网-linux","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-linux/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"优化","slug":"优化","link":"/categories/%E4%BC%98%E5%8C%96/"},{"name":"js javascript","slug":"js-javascript","link":"/categories/js-javascript/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"linux ubuntu20.04 树莓派","slug":"linux-ubuntu20-04-树莓派","link":"/categories/linux-ubuntu20-04-%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"漆器","slug":"漆器","link":"/categories/%E6%BC%86%E5%99%A8/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"axios token refresh token","slug":"axios-token-refresh-token","link":"/categories/axios-token-refresh-token/"},{"name":"thymeleaft3","slug":"thymeleaft3","link":"/categories/thymeleaft3/"}]}